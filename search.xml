<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell-challenge</title>
      <link href="/2024/08/29/shell-challenge/"/>
      <url>/2024/08/29/shell-challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="shell-challenge"><a href="#shell-challenge" class="headerlink" title="shell-challenge"></a>shell-challenge</h1><h2 id="task1：实现不带-b-后缀指令"><a href="#task1：实现不带-b-后缀指令" class="headerlink" title="task1：实现不带 .b 后缀指令"></a>task1：实现不带 .b 后缀指令</h2><p><code>user/lib/spawn.c</code>中在尝试打开程序路径失败后，检查是否是.b结尾，如果不是，更改为以.b结尾再次尝试打开。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/lib/spawn.c</span><span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>prog<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// delete:return fd;</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>prog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> prog<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'b'</span> <span class="token operator">||</span> prog<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> tmp_prog<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>tmp_prog<span class="token punctuation">,</span> prog<span class="token punctuation">)</span><span class="token punctuation">;</span>        tmp_prog<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span>        tmp_prog<span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>        tmp_prog<span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>tmp_prog<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> fd<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task2：实现指令条件执行"><a href="#task2：实现指令条件执行" class="headerlink" title="task2：实现指令条件执行"></a>task2：实现指令条件执行</h2><p>指令条件执行与一行多指令相似，只是需要进一步判断要不要执行下一条。</p><ol><li><p>修改 <code>parsecmd</code> 函数，使其能够解析 <code>&amp;&amp;</code> 和 <code>||</code> 运算符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sh.c</span><span class="token keyword">int</span> <span class="token function">_gettoken</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// ...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'&amp;'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'&amp;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>p1 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>s<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        s <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token char">'a'</span><span class="token punctuation">;</span> <span class="token comment">// 'a' stands for &amp;&amp;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'|'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'|'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>p1 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token char">'o'</span><span class="token punctuation">;</span> <span class="token comment">// 'o' stands for ||</span>    <span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改 <code>runcmd</code> 函数，通过ipc通信来判断是否要执行下一条指令。</p><p>以<code>&amp;&amp;</code>为例：</p><p>fork出的子进程将need_to_send设为1后执行解析完毕的命令</p><p>父进程通过接受的返回值①判断要不要继续执行，基本逻辑是：</p><ul><li>如果返回0，继续执行后面的指令</li><li>否则，在这条指令之后如果有’||’，可以执行’||’之后的内容，否则退出</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">parsecmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>rightpipe<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> argc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>need_to_send <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 发回执行消息</span>back_commend <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 是否是后台指令</span><span class="token keyword">char</span> <span class="token operator">*</span>t<span class="token punctuation">;</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> r<span class="token punctuation">;</span><span class="token keyword">int</span> left<span class="token punctuation">;</span><span class="token comment">// 条件指令</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">gettoken</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ...</span><span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>  <span class="token comment">// &amp;&amp;</span>left <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>r <span class="token operator">=</span> <span class="token function">ipc_recv</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//①</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">parsecmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> op <span class="token operator">=</span> <span class="token function">gettoken</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token char">'o'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">parsecmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>need_to_send <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> argc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">// ...</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> argc<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步的，子进程通过spawn出的child执行命令，在sh.c的<code>runcmd</code>做出如下修改：</p><p>如果need_to_send为1，子进程需要向父进程发送执行完毕的返回值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>back_commend <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">syscall_add_job</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> back_cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token function">close_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">ipc_recv</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ②</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_to_send<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">ipc_send</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_parent_id<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">wait</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"spawn %s: %d\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②处ipc_recv对应的ipc_send是：由于<code>user/lib/libos.c</code>的libmain函数调用了<code>main</code>函数，可以在libmain的结尾通过ipc_send传输<code>main</code>的返回值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">libmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// set env to point at our env structure in envs[].</span>env <span class="token operator">=</span> <span class="token operator">&amp;</span>envs<span class="token punctuation">[</span><span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">syscall_getenvid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// call user main routine</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ipc_send</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_parent_id<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// exit gracefully</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="task3：实现更多指令"><a href="#task3：实现更多指令" class="headerlink" title="task3：实现更多指令"></a>task3：实现更多指令</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>通过IPC实现用户进程和文件系统服务进程的交互，实现文件系统服务进程创建文件的接口。</p><ol><li><p>用户：在user/include/fsreq.h中定义结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>FSREQ_OPEN<span class="token punctuation">,</span>FSREQ_MAP<span class="token punctuation">,</span>FSREQ_SET_SIZE<span class="token punctuation">,</span>FSREQ_CLOSE<span class="token punctuation">,</span>FSREQ_DIRTY<span class="token punctuation">,</span>FSREQ_REMOVE<span class="token punctuation">,</span>FSREQ_SYNC<span class="token punctuation">,</span>FSREQ_CREATE<span class="token punctuation">,</span><span class="token comment">// add</span>MAX_FSREQNO<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fsreq_create</span> <span class="token punctuation">{</span><span class="token keyword">char</span> req_path<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>u_int f_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用户：在user/include/lib.h中声明以下函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//fsipc.c</span><span class="token keyword">int</span> <span class="token function">fsipc_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> u_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//file.c</span><span class="token keyword">int</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> u_int f_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在user/lib/fsipc.c中完成<code>fsipc_creat</code>函数，与文件系统进程进行ipc通信。<br>在user/lib/file.c中完成<code>creat</code>函数，对<code>fsipc_creat</code>进行封装，供用户进程调用。</p></li><li><p>文件系统：在fs/serv.h中声明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">file_create</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在fs/serv.c中完成<code>serve_create</code>函数并在serve_table中添加<code>[FSREQ_CREATE] = serve_create</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">serve_create</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Fsreq_create</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_create</span><span class="token punctuation">(</span>rq<span class="token operator">-&gt;</span>req_path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">ipc_send</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    f<span class="token operator">-&gt;</span>f_type <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>f_type<span class="token punctuation">;</span><span class="token comment">// file_create未设置文件类型，需重新设置</span><span class="token function">ipc_send</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//user/touch.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;lib.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">usage</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage: touch [filename]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// printf("argc = %d\n", argc);</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打开文件</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 文件存在</span>        <span class="token function">close</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 不存在则创建</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">create</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> FTYPE_REG<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"touch: cannot touch \'%s\': No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;lib.h&gt;</span></span><span class="token keyword">int</span> flag<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">usage</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage: mkdir &lt;dir&gt;\n\    -p: no error send if existing \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// printf("brfore argc = %d\n", argc);</span>    ARGBEGIN <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token char">'p'</span><span class="token operator">:</span>flag<span class="token punctuation">[</span><span class="token punctuation">(</span>u_char<span class="token punctuation">)</span><span class="token function">ARGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ARGEND    <span class="token comment">// printf("after argc = %d\n", argc);</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打开文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 文件存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span><span class="token char">'p'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mkdir: cannot create directory \'%s\': File exists\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">close</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 文件不存在</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">create</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> FTYPE_DIR<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span><span class="token char">'p'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mkdir: cannot create directory \'%s\': No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 递归创建文件：循环识别/并尝试打开，打开失败则创建文件</span>            <span class="token keyword">char</span> path<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">strcpy</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>                    r <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">close</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        r <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> FTYPE_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"some err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>             <span class="token punctuation">}</span>            r <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> FTYPE_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"some err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p><code>rm</code>函数：根据可选项执行相应操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">rm</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Stat</span> st<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 获取文件状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span><span class="token char">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: cannot remove \'%s\': No such file or directory\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>st_isdir <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 文件目录-&gt;判断可选项是否满足</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token char">'r'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: cannot remove '%s': No such file or directory\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: cannot remove '%s': Is a directory\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 文件-&gt;直接删除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: cannot remove '%s': No such file or directory\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数：处理可选项及调用rm函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// printf("brfore argc = %d\n", argc);</span>    ARGBEGIN <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token char">'r'</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token char">'f'</span><span class="token operator">:</span>        flag<span class="token punctuation">[</span><span class="token punctuation">(</span>u_char<span class="token punctuation">)</span><span class="token function">ARGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ARGEND    <span class="token comment">// printf("after argc = %d\n", argc);</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    u_int i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rm</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task4：实现反引号"><a href="#task4：实现反引号" class="headerlink" title="task4：实现反引号"></a>task4：实现反引号</h2><p>在识别到`之后，提取出反引号内的指令并调用<code>runcmd()</code>函数（注：反引号的识别最好放在第一步，并需要在结束之后再次执行一次准备工作）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sh.c</span><span class="token keyword">int</span> <span class="token function">_gettoken</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 一些准备工作：判断指令是否为空 跳过空白符 判断是否到达结尾</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">strchr</span><span class="token punctuation">(</span>WHITESPACE<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>s<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token comment">// 识别`</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'`'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取并执行反引号中的指令</span>s<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>s <span class="token operator">!=</span> <span class="token char">'`'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cmd<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>        s<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"syntax error: unmatched \"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cmd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">runcmd</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重复识别到`之前的操作 返回到识别token的准备状态</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">strchr</span><span class="token punctuation">(</span>WHITESPACE<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>s<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">// ... 继续识别token</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task5：实现注释功能"><a href="#task5：实现注释功能" class="headerlink" title="task5：实现注释功能"></a>task5：实现注释功能</h2><p>修改<code>int _gettoken(char *s, char **p1, char **p2) </code>函数，在识别到’#’后相当于指令已经结束，将该位置设为<code>\0</code>后直接返回即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sh.c</span><span class="token keyword">int</span> <span class="token function">_gettoken</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Null-terminate the command before the comment</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ... 继续识别token</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task6：实现历史指令"><a href="#task6：实现历史指令" class="headerlink" title="task6：实现历史指令"></a>task6：实现历史指令</h2><h3 id="history部分定义函数及相关声明"><a href="#history部分定义函数及相关声明" class="headerlink" title="history部分定义函数及相关声明"></a>history部分定义函数及相关声明</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// sh.c</span><span class="token keyword">void</span> <span class="token function">save_history</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保存指令</span><span class="token keyword">int</span> <span class="token function">lookup_history</span><span class="token punctuation">(</span><span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 上下键切换指令</span><span class="token keyword">int</span> <span class="token function">history_print</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// history命令</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HISTORY_FILE</span> <span class="token string">"/.mosh_history"</span><span class="token comment">// 历史记录文件的存储路径</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HISTFILESIZE</span> <span class="token expression"><span class="token number">20</span></span><span class="token comment">// 存储大小</span></span><span class="token keyword">char</span> history<span class="token punctuation">[</span>HISTFILESIZE<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1025</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 存储历史记录的临时数组</span><span class="token keyword">int</span> history_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 记录存储个数</span><span class="token keyword">int</span> history_file_fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//</span><span class="token keyword">static</span> <span class="token keyword">int</span> current_history_index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 当前命令下标</span><span class="token keyword">char</span> input_cmd<span class="token punctuation">[</span><span class="token number">1025</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 控制台当前输入</span><span class="token keyword">char</span> input_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// input_cmd中是否需要更新 0:需要更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h3><ul><li><p><code>void save_history(char *cmd)</code></p><blockquote><p>char * cmd：输入的命令</p></blockquote></li></ul><p>在读取控制台输入结束后调用save_history即可。</p><p>在存储未满时写入文件需要以<code>O_APPEND</code>的形式打开，需要先实现一下<code>O_APPEND</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">save_history</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> flag_full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 记录存储是否已满</span><span class="token keyword">if</span> <span class="token punctuation">(</span>history_count <span class="token operator">==</span> HISTFILESIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>flag_full <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> HISTFILESIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">strcpy</span><span class="token punctuation">(</span>history<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> history<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        history_count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>history<span class="token punctuation">[</span>history_count<span class="token punctuation">]</span><span class="token punctuation">,</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>history_count<span class="token operator">++</span><span class="token punctuation">;</span>current_history_index <span class="token operator">=</span> history_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>input_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 完成存储历史记录的临时数组的更新 完成相关管理数据的更新</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag_full<span class="token punctuation">)</span> <span class="token punctuation">{</span>        history_file_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>HISTORY_FILE<span class="token punctuation">,</span> O_WRONLY <span class="token operator">|</span> O_CREAT <span class="token operator">|</span> O_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>history_file_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"/.mosh_history open in err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">write</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        history_file_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>HISTORY_FILE<span class="token punctuation">,</span> O_WRONLY <span class="token operator">|</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>history_file_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"/.mosh_history open in err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> history_count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">write</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">,</span> history<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>history<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">write</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>history_file_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 写入历史记录文件 注意历史文件中命令是以'\n'结尾 方便打印</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>int lookup_history(int op, char* buf)</code></li></ul><blockquote><p>op：1代表输入上键 0代表输入下键</p><p>buf：当前控制台输入内容的缓冲区</p><p>返回值：完成上下键切换后buf中的指令长度</p></blockquote><p>此函数主要用于辅助实现上下键切换，在sh.c的<code>readline</code>函数中添加如下进行调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">char</span> tmp<span class="token punctuation">;</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 将此时控制台输入的命令末尾写入'\0'</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token char">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//up</span>i <span class="token operator">=</span> <span class="token function">lookup_history</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token char">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//down</span>i <span class="token operator">=</span> <span class="token function">lookup_history</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>i<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lookup_history</span><span class="token punctuation">(</span><span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// up:1 down:0</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// flag为1代表第一次进行上下键切换</span><span class="token keyword">if</span> <span class="token punctuation">(</span>input_flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// input_flag为0代表需要更新记录当前输入的命令</span>input_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>input_cmd<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>input_cmd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过输出左键-空格-左键的方式在控制台删除一个字符(但是好像不能实时显示)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 上键</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c[B"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不许乱动</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>current_history_index <span class="token operator">=</span> current_history_index <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> current_history_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>current_history_index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>history<span class="token punctuation">[</span>current_history_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> history<span class="token punctuation">[</span>current_history_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> input_cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 下键</span><span class="token keyword">if</span> <span class="token punctuation">(</span>current_history_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> history_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> input_cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>current_history_index <span class="token operator">=</span> current_history_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>history<span class="token punctuation">[</span>current_history_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> history<span class="token punctuation">[</span>current_history_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 由于用户在控制台新输入的指令后续还需要更改 输出到'\0'之前即可</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token comment">// 需要返回buf中的指令长度更新readline中的i</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>int history_print(int argc, char** argv);</code></li></ul><blockquote><p>argc、argv即命令的参数个数和参数数组</p><p>由于不能自行更改user/include.mk，history指令也应该在sh.c中完成</p></blockquote><p>在sh.c的<code>runcmd</code>函数中添加如下进行调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">"history"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">history_print</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">wait</span><span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接逐个字符读取打印输出即可（先前存储指令时我们让指令以’\n’结尾 无需考虑换行）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">history_print</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">char</span> buf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage: history\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>HISTORY_FILE<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open /.mosh_history in err\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> fd <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task7：实现一行多指令"><a href="#task7：实现一行多指令" class="headerlink" title="task7：实现一行多指令"></a>task7：实现一行多指令</h2><p><code>#define SYMBOLS "&lt;|&gt;&amp;;()"</code>中已经定义<code>;</code></p><p>修改sh.c中<code>int parsecmd(char **argv, int *rightpipe)</code>函数，添加<code>case ';'</code>，使fork出的子进程执行已经解析完成的命令，父进程等待子进程执行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">case</span> <span class="token char">';'</span><span class="token operator">:</span>left <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">wait</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">parsecmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> argc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task8：实现追加重定向"><a href="#task8：实现追加重定向" class="headerlink" title="task8：实现追加重定向"></a>task8：实现追加重定向</h2><ol><li><p>在<code>int _gettoken(char *s, char **p1, char **p2) </code>中增加识别<code>&gt;&gt;</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'&gt;'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'&gt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>p1 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token char">'A'</span><span class="token punctuation">;</span> <span class="token comment">// 'A' stands for APPEND</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>int parsecmd(char **argv, int *rightpipe)</code>函数，添加<code>case 'A'</code>进行相应处理</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">case</span> <span class="token char">'A'</span><span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">gettoken</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'w'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"syntax error: &gt; not followed by word\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"error in open %s\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果不存在文件创建文件</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> O_WRONLY <span class="token operator">|</span> O_APPEND<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">debugf</span><span class="token punctuation">(</span><span class="token string">"syntax error: &gt;&gt; followed the word: %s cannot open\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">dup</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将文件以O_WRONLY | O_APPEND形式打开进行写入</span><span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="task9：实现引号支持"><a href="#task9：实现引号支持" class="headerlink" title="task9：实现引号支持"></a>task9：实现引号支持</h2><p>在<code>int _gettoken(char *s, char **p1, char **p2) </code>中增加识别<code>\"</code>，将引号中的内容以<code>'w'</code>的类型返回即可。</p>   <pre class="line-numbers language-c" data-language="c"><code class="language-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">==</span> <span class="token char">'"'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   s<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token operator">*</span>p1 <span class="token operator">=</span> s<span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>s <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>s <span class="token operator">!=</span> <span class="token char">'"'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       s<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"syntax error: unmatched \"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>s<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token operator">*</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token char">'w'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="task10：实现前后台任务管理"><a href="#task10：实现前后台任务管理" class="headerlink" title="task10：实现前后台任务管理"></a>task10：实现前后台任务管理</h2><blockquote><p>考虑：如果是后台指令，在每次在执行结束销毁进程之前需要把它的status由JOB_RUNNING变为JOB_DONE，而销毁进程属于系统调用的指令，所以可以将对job的相关管理放在内核态中，由用户态通过系统调用进行。</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在<code>int parsecmd(char **argv, int *rightpipe)</code>函数，添加<code>case '&amp;'</code>实现指令在后台处理</p><p>设立back_commend标志当前进程执行的是后台指令，与实现一行多指令相比父进程无须等待子进程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">case</span> <span class="token char">'&amp;'</span><span class="token operator">:</span>       left  <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">parsecmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>back_commend <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> argc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="job管理"><a href="#job管理" class="headerlink" title="job管理"></a>job管理</h3><p>由于把对job的相关管理放在内核，需要实现一系列的系统调用</p><ol><li><p>kern/syscall_all.c中相关结构体和函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXJOBS</span> <span class="token expression"><span class="token number">128</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">JOB_RUNNING</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">JOB_DONE</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> job_id<span class="token punctuation">;</span>    <span class="token keyword">int</span> env_id<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token class-name">job_t</span><span class="token punctuation">;</span><span class="token class-name">job_t</span> jobs<span class="token punctuation">[</span>MAXJOBS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> next_job_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照实现系统调用的一般方式</p><p>kern/syscall_all.c实现具体函数并在syscall_table中添加-&gt; include/syscall.h添加枚举类型 -&gt; user/lib/syscall_lib.c中包装msyscall-&gt;user/include/lib.h声明  </p><p>需要为用户提供如下系统调用接口：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/include/lib.h</span><span class="token comment">// job</span><span class="token keyword">void</span> <span class="token function">syscall_add_job</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">syscall_list_jobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">syscall_kill_job</span><span class="token punctuation">(</span><span class="token keyword">int</span> job_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">syscall_find_job_envid</span><span class="token punctuation">(</span><span class="token keyword">int</span> job_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常执行结束的后台指令的状态设置直接在sys_env_destroy函数中进行：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_env_destroy</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXJOBS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jobs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>env_id <span class="token operator">==</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>            jobs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// printk("%d set to done\n", envid);</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"[%08x] destroying %08x\n"</span><span class="token punctuation">,</span> curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">,</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">env_destroy</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="相关调用"><a href="#相关调用" class="headerlink" title="相关调用"></a>相关调用</h3><ul><li><p><code>jobs</code></p><p>在sh.c的<code>runcmd</code>函数中添加如下进行调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">"jobs"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">syscall_list_jobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">wait</span><span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>kill</code></p><p>在sh.c的<code>runcmd</code>函数中添加如下进行调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">"kill"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> job_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>job_id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> job_id <span class="token operator">+</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">syscall_kill_job</span><span class="token punctuation">(</span>job_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">wait</span><span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>fg</code></p><p>在sh.c的<code>runcmd</code>函数中添加如下进行调用：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> job_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            job_id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> job_id <span class="token operator">+</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> env_id <span class="token operator">=</span> <span class="token function">syscall_find_job_envid</span><span class="token punctuation">(</span>job_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>env_id <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span>env_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span>rightpipe<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>添加job</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>cmd_ptr <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment">// 记录输入的首地址</span><span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token number">1025</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 拷贝保存控制台输入</span>    <span class="token comment">// ...</span>    <span class="token keyword">char</span> back_cmd<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>back_commend <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是后台指令 下一步拆分得到具体指令内容</span>        <span class="token keyword">int</span> begin_index <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> cmd_ptr<span class="token punctuation">;</span><span class="token comment">// 指令开始的下标</span>        <span class="token keyword">int</span> end_index <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> cmd_ptr <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'&amp;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end_index <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 指令结束的下标</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>back_cmd<span class="token punctuation">,</span> cmd <span class="token operator">+</span> begin_index<span class="token punctuation">)</span><span class="token punctuation">;</span>        back_cmd<span class="token punctuation">[</span>end_index <span class="token operator">-</span> begin_index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>back_commend <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">syscall_add_job</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> back_cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过系统调用添加job</span>    <span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab6</title>
      <link href="/2024/08/29/2024-os-lab6/"/>
      <url>/2024/08/29/2024-os-lab6/</url>
      
        <content type="html"><![CDATA[<h1 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想 让父进程作为“读者”，代码应当如何修改？</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 互换源代码中父子进程部分</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">0</span> <span class="token operator">:</span><span class="token comment">// 子进程</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">write</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Hello world\n"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Write data on pipe */</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token operator">:</span><span class="token comment">// 父进程</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">read</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Get data from pipe */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child-process read:%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Print the data */</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中 的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的dup函数中为什么会出现预想之外的情况？</p></blockquote><p><code>dup</code>函数将<code>oldfdnum</code>所代表的文件描述符指向的数据复制给<code>newfdnum</code>文件描述符，包括</p><ol><li><p>将<code>newfd</code>所在的虚拟页映射到<code>oldfd</code>所在的物理页</p></li><li><p>将<code>newfd</code>的数据所在的虚拟页映射到<code>oldfd</code>的数据所在的物理页</p></li></ol><p>如果先映射fd0，再映射pipe：在pipe没有映射完毕时进程被中断(fd0已经+1，但pipe还没有来得及+1)，可能会导致另一进程调用<code>pipe_is_closed</code>，发现<code>pageref(fd[0]) = pageref(pipe)</code>，误以为读/写端已经关闭。</p><h3 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h3><blockquote><p>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。</p></blockquote><p>进程切换是通过定时器产生时钟中断，触发时钟中断切换进程。但是syscall跳转到内核态后，关闭了时钟中断。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">exc_gen_entry<span class="token operator">:</span>SAVE_ALL<span class="token comment">/** Note: When EXL is set or UM is unset, the processor is in kernel mode.* When EXL is set, the value of EPC is not updated when a new exception occurs.* To keep the processor in kernel mode and enable exception reentrancy,* we unset UM and EXL, and unset IE to globally disable interrupts.*/</span>mfc0    t0<span class="token punctuation">,</span> CP0_STATUSand     t0<span class="token punctuation">,</span> t0<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>STATUS_UM <span class="token operator">|</span> STATUS_EXL <span class="token operator">|</span> STATUS_IE<span class="token punctuation">)</span>mtc0    t0<span class="token punctuation">,</span> CP0_STATUS<span class="token comment">/* Exercise 3.9: Your code here. */</span>mfc0t0<span class="token punctuation">,</span> CP0_CAUSEandit0<span class="token punctuation">,</span> <span class="token number">0x7c</span>lwt0<span class="token punctuation">,</span> <span class="token function">exception_handlers</span><span class="token punctuation">(</span>t0<span class="token punctuation">)</span>jrt0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h3><blockquote><p>按照上述说法控制 pipe_close中 fd和 pipe unmap的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</p></blockquote><p>可以。ref(p[0]) &lt; ref(pipe)， 如果先解除p[0]的映射，只会让小的更小，从而避免出现相等的情况。</p><blockquote><p>我们只分析了 close时的情形，在 fd.c中有一个 dup函数，用于复制文件描述符。 试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close类似的问 题？请模仿上述材料写写你的理解。</p></blockquote><p><code>dup</code>函数也会出现与<code>close</code>类似的问题。pipe的引用次数总比fd要高。当管道的<code>dup</code>进行到一半时， 如果先映射fd，再映射 pipe，就会使fd的引用次数的+1先于pipe(即Thinking 6.2 中的情况)，导致在两个<code>map</code>的间隙，可能出现<code>pageref(pipe) == pageref(fd)</code>。</p><p>这个问题也可以通过调换两个map的顺序来解决。</p><h3 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h3><blockquote><p> 思考以下三个问题。 </p><ul><li><p>认真回看Lab5文件系统相关代码，弄清打开文件的过程。 </p></li><li><p>回顾Lab1与Lab3，思考如何读取并加载ELF文件。</p></li><li><p>在Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss段存放未初始化的全局变量。关于memsize和filesize，我们在Note 1.3.4中也解释了它们的含义与特点。关于Note1.3.4，注意其中关于“bss段并不在文件中占数据”表述的含义。回顾Lab3并思考：elf_load_seg()和load_icode_mapper() 函数是如何确保加载ELF文件时，bss段数据被正确加载进虚拟内存空间。bss段在ELF中并不占空间，但ELF加载进内存后，bss段的数据占据了空间，并且初始值都是0。请回顾elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？</p></li></ul></blockquote><blockquote><p>下面给出一些对于上述问题的提示，以便大家更好地把握加载内核进程和加载用户进程的区别与联系，类比完成 spawn函数。</p></blockquote><p>关于第一个问题，在Lab3中我们创建进程，并且通过 ENV_CREATE(…) 在内核态加载了初始进程，而我们的 spawn函数则是通过和文件系统交互，取得文件描述块，进而找到ELF 在“硬盘”中的位置，进而读取。 </p><p>关于第二个问题，各位已经在Lab3中填写了load_icode 函数，实现了ELF 可执行文件中读取数据并加载到内存空间，其中通过调用elf_load_seg 函数来加载各个程序段。 在Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存空间；相应地，在Lab6中spawn函数也需要在用户态下使用系统调用为ELF数据分配空间。</p><p>当加载到<code>bin_size~sgsize</code>之间的数据时，就知道新入了<code>bss</code>端，使用<code>bzero</code>函数赋值为0，不需要再读取ELF的数据。</p><h3 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h3><blockquote><p> 通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其dup到0或1号文件描述符（fd）。那么问题来了：在哪步，0和1被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user\init.c</span><span class="token comment">// stdin should be 0, because no file descriptors are open yet</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">opencons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"opencons: %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// stdout</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"dup: %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h3><blockquote><p> 在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时shell不需要fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子shell，然后子 shell 去执行这条命令。 </p><p> 据此判断，在MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？</p></blockquote><img src="/2024/08/29/2024-os-lab6/img/image-20240611091953973.png" style="zoom:50%;"><p>shell命令是外部命令，因为在执行shell命令时，当前进程通过<code>fork</code>产生一个子进程，也就是子shell，然后这个子shell来运行该命令所对应的可执行文件。</p><ul><li>linux中的内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。因为<code>cd</code>指令非常简单，将其作为内部命令写在bashy源码里面的，可以避免每次执行都需要fork并加载程序，提高执行效率。</li></ul><h3 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h3><blockquote><p> 在你的 shell 中输入命令 ls.b | cat.b &gt; motd。 </p><p> 请问你可以在你的shell 中观察到几次spawn？分别对应哪个进程？</p></blockquote><p>有两次spawn，分别打开了ls.b，cat.b进程</p><blockquote><p> 请问你可以在你的shell 中观察到几次进程销毁？分别对应哪个进程？</p></blockquote><p>有四个进程的销毁，分别是左指令的执行进程，右指令的执行进程，spawn打开的两个执行进程。</p><img src="/2024/08/29/2024-os-lab6/img/image-20240610230034216.png" style="zoom:50%;"><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h4 id="管道竞争问题"><a href="#管道竞争问题" class="headerlink" title="管道竞争问题"></a>管道竞争问题</h4><p>感谢同学在讨论区分享！</p><img src="/2024/08/29/2024-os-lab6/img/image-20240611093714046.png"><h4 id="spawn函数流程"><a href="#spawn函数流程" class="headerlink" title="spawn函数流程"></a>spawn函数流程</h4><ol><li>使用文件系统提供的 open函数打开即将装载的 ELF文件 prog。</li><li>使用系统调用 syscall_exofork 函数为子进程申请一个进程控制块。 </li><li>使用 init_stack 函数为子进程初始化栈空间，将需要传递的参数 argv传入子进程。 </li><li>使用 elf_load_seg 将 ELF 文件的各个段加载进子进程。 </li><li>设置子进程的运行现场寄存器，将 tf-&gt;cp0_epc设置为程序入口点，tf-&gt;regs[29]设置 为装载参数后的栈顶指针，从而在子进程被唤醒时以正确的状态开始运行。 </li><li>将父进程的共享页面映射给子进程，与 fork不同的是，这里只映射共享页面。 7. 使用系统调用 syscall_set_env_status 唤醒子进程。</li></ol><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>在此个lab中，学习了解了管道的原理与底层的一些细节，实现了基本shell。可能是课程马上要结束，从lab5开始就慢慢有一种力不从心的感觉，看很久很久才能参悟到一点点（好吧面对庞大精细的操作系统我应该还有很多很多远远不知道的内容）。不管怎样，去慢慢地尝试一点点丰富构造MOS确实是一个很酷的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab5</title>
      <link href="/2024/08/29/2024-os-lab5/"/>
      <url>/2024/08/29/2024-os-lab5/</url>
      
        <content type="html"><![CDATA[<h1 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><blockquote><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p></blockquote><p>当外部设备自身更新数据时，如果此时CPU写入外设的数据还只在缓存中，<strong>则缓存的那部分数据就只能在外设自身更新后再写入外设</strong>（只有缓存块将要被新进入的数据取代时，缓存数据才会被写入内存），这样就会发生错误的行为。</p><p><mark>设备物理内存处的数据不只由 CPU 决定，还和对应的外设的行为有关。而缓存只能记录 CPU 的读写结果，无法在外设对数据进行修改时及时调整。</mark></p><p>串口设备读写频繁，而IDE磁盘读写频率相对较小，因此串口设备发生错误的概率要远大于IDE磁盘。</p><p>😊from Hyggge</p><h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/include/fs.h</span><span class="token comment">// 一个磁盘块的容量为4KB</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLOCK_SIZE</span> <span class="token expression">PAGE_SIZE</span></span><span class="token comment">// 文件控制块都被数组f_pad强制对齐为256B</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token punctuation">{</span><span class="token keyword">char</span> f_name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// filename</span><span class="token class-name">uint32_t</span> f_size<span class="token punctuation">;</span> <span class="token comment">// file size in bytes</span><span class="token class-name">uint32_t</span> f_type<span class="token punctuation">;</span> <span class="token comment">// file type</span><span class="token class-name">uint32_t</span> f_direct<span class="token punctuation">[</span>NDIRECT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> f_indirect<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f_dir<span class="token punctuation">;</span> <span class="token comment">// the pointer to the dir where this file is in, valid only in memory.</span><span class="token keyword">char</span> f_pad<span class="token punctuation">[</span>FILE_STRUCT_SIZE <span class="token operator">-</span> MAXNAMELEN <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> NDIRECT<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE2BLK</span> <span class="token expression"><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个磁盘块中最多能存储16个文件控制块</li><li>一个目录下最多能有4KB/4B * 16 = 1024*16 = 16384个文件</li><li>单个文件最大为4KB/4B * 4KB = 4MB</li></ul><h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最 大磁盘大小是多少？</p></blockquote><p>块缓存所在的地址空间为<code>[0x10000000, 0x50000000)</code>,因此我们的内核能够支持的磁盘大小为<code>0x40000000</code>,也就是1GB。</p><h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><blockquote><p>在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义， 试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// fs/serv.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SECT_SIZE</span> <span class="token expression"><span class="token number">512</span>  </span><span class="token comment">/* Bytes per disk sector */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SECT2BLK</span> <span class="token expression"><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">/</span> SECT_SIZE<span class="token punctuation">)</span> </span><span class="token comment">/* sectors to a block */</span></span><span class="token comment">/* Disk block n, when in memory, is mapped into the file system * server's address space at DISKMAP+(n*BLOCK_SIZE). */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISKMAP</span> <span class="token expression"><span class="token number">0x10000000</span></span></span><span class="token comment">/* Maximum disk size we can handle (1GB) */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISKMAX</span> <span class="token expression"><span class="token number">0x40000000</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/include/fs.h</span><span class="token comment">// Bytes per file system block - same as page size</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLOCK_SIZE</span> <span class="token expression">PAGE_SIZE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLOCK_SIZE_BIT</span> <span class="token expression"><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span></span></span><span class="token comment">// Number of (direct) block pointers in a File descriptor</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NDIRECT</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NINDIRECT</span> <span class="token expression"><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXFILESIZE</span> <span class="token expression"><span class="token punctuation">(</span>NINDIRECT <span class="token operator">*</span> BLOCK_SIZE<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE_STRUCT_SIZE</span> <span class="token expression"><span class="token number">256</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// user/include/fd.h </span><span class="token comment">// 找fd对应的文件信息页面和文件缓存区地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">INDEX2FD</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">(</span>FDTABLE <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span>BY2PG<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">INDEX2DATA</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">(</span>FILEBASE <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span>PDMAP<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>在Lab4“系统调用与fork”的实验中我们实现了极为重要的fork函数。那 么fork前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</p></blockquote><p>一个进程所有的文件描述符都存储在<code>[FDTABLE, FILEBASE)</code>这一地址空间中。在<code>fork</code>函数执行时，会将这父进程页表中映射一部分地址的页表项拷贝到子进程的页表中，因此<code>fork</code>前后的父子进程会共享文件描述符和定位指针。</p><h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><blockquote><p>请解释File,Fd,Filefd结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// usr/include/fd.h</span><span class="token comment">// file descriptor</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token punctuation">{</span>u_int fd_dev_id<span class="token punctuation">;</span><span class="token comment">// 外设id</span>u_int fd_offset<span class="token punctuation">;</span><span class="token comment">// 读写偏移量</span>u_int fd_omode<span class="token punctuation">;</span><span class="token comment">// 打开方式</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// file descriptor + file</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> f_fd<span class="token punctuation">;</span>u_int f_fileid<span class="token punctuation">;</span><span class="token comment">// 文件id</span><span class="token keyword">struct</span> <span class="token class-name">File</span> f_file<span class="token punctuation">;</span><span class="token comment">// 对应文件的文件控制块</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Fd结构体主要用于记录已打开文件的状态，便于用户直接使用文件描述符对文件进行操作、申请服务等等。由于文件描述符主要是为用户所使用，因此它对应的是磁盘映射到内存中的数据。</p><ul><li>fd_dev_id:不同的dev_id会调取不同的文件服务函数</li><li>fd_offset:seek()时修改 offset会被用来找起始filebno文件块号</li><li>fd_omode:req和open结构体都会用到</li></ul><p>文件描述符中存储的数据毕竟是有限的，有的时候我们需要将<code>Fd*</code>强制转换为<code>Filefd*</code>从而获取到文件控制块，从而获得更多文件信息，比如文件大小等等。Fd和Field只是对一个位置上的数据不同的解释方式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// usr/include/fs.h</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token punctuation">{</span><span class="token keyword">char</span> f_name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// filename</span><span class="token class-name">uint32_t</span> f_size<span class="token punctuation">;</span> <span class="token comment">// file size in bytes</span><span class="token class-name">uint32_t</span> f_type<span class="token punctuation">;</span> <span class="token comment">// file type</span><span class="token class-name">uint32_t</span> f_direct<span class="token punctuation">[</span>NDIRECT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 文件的直接指针,用来记录文件的数据块在磁盘上的位置</span><span class="token class-name">uint32_t</span> f_indirect<span class="token punctuation">;</span><span class="token comment">// 指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f_dir<span class="token punctuation">;</span> <span class="token comment">// the pointer to the dir where this file is in, valid only in memory.</span><span class="token keyword">char</span> f_pad<span class="token punctuation">[</span>FILE_STRUCT_SIZE <span class="token operator">-</span> MAXNAMELEN <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> NDIRECT<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h3><img src="/2024/08/29/2024-os-lab5/img/image-20240525224651336.png " style="zoom:70%;"><blockquote><p>图 5.9 中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们 的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><img src="/2024/08/29/2024-os-lab5/img/image-20240529001747732.png" style="zoom:15%;"><p>fs_serv循环调用<code>ipc_recv</code>函数，在这个函数被调用后，fs_serv就会主动让出CPU（进程状态被标记为<code>NOT_RANNABLE</code>）。直到user_env调用<code>ipc_send</code>向fs_serv申请服务，fs_serv被唤醒，后user_serv调用<code>ipc_recv</code>，user_serv让出cpu。fs_serv处理结束后，fs_serv调用<code>ipc_send</code>唤醒user_env。fs_serv进入下一次循环，调用<code>ipc_recv</code>重复上述过程。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h3><ol><li>了解文件系统的基本概念和作用。 </li><li>了解普通磁盘的基本结构和读写方式。 </li><li>了解实现设备驱动的方法。 </li><li>掌握并实现文件系统服务的基本操作。 </li><li>了解微内核的基本设计思想和结构。</li></ol><p>补充lab4相关：接收方进程先recv发送方进程才能成功发送</p><p><code>u_int ipc_recv(u_int *whom, void *dstva, u_int *perm)</code></p><p>if (whom) -&gt; *whom为所收到消息的发送方id</p><p>if(perm) -&gt; *perm为收到信息的权限</p><p>dstva：接受消息的地址；返回值为发送的值</p><p><code>int sys_ipc_recv(u_int dstva)</code></p><p>设置当前进程env_ipc_recving为1，env_ipc_dstvs为dstva，env_status为ENV_NOT_RUNNABLE并插入对应进程队列，返回成功发送/错误值</p><p><code>void ipc_send(u_int whom, u_int val, const void *srcva, u_int perm) </code></p><p>调用sys_ipc_try_send</p><p><code>int sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</code></p><p>向envid进程发送value(srcva不为零时向接收方进程的env_ipc_dstvs插入一页)，返回成功发送/错误值</p><h4 id="kern"><a href="#kern" class="headerlink" title="/kern"></a>/kern</h4><h5 id="syscall-all-c"><a href="#syscall-all-c" class="headerlink" title="syscall_all.c"></a>syscall_all.c</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_write_dev</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">,</span> u_int pa<span class="token punctuation">,</span> u_int len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sys_read_dev</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">,</span> u_int pa<span class="token punctuation">,</span> u_int len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="tools-存放的是构建时辅助工具的代码。"><a href="#tools-存放的是构建时辅助工具的代码。" class="headerlink" title="/tools :存放的是构建时辅助工具的代码。"></a>/tools :存放的是构建时辅助工具的代码。</h4><h5 id="fsformat-c：创建磁盘镜像。"><a href="#fsformat-c：创建磁盘镜像。" class="headerlink" title="fsformat.c：创建磁盘镜像。"></a>fsformat.c：创建磁盘镜像。</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">write_directory</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">write_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将宿主机上路径为path的【目录（及其下所有目录和文件）/文件】写入磁盘镜像中drif所指向的文件控制块所代表的目录下</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token function">create_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在给定目录下分配新的文件控制块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>  请注意，tools目录下的代码仅用于MOS的构建，在宿主Linux环境（而非 MIPS 模拟器）中运行，也不会被编译进MOS的内核、用户库或用户程序中。 </p><h4 id="fs-存放的是文件系统服务进程的代码。"><a href="#fs-存放的是文件系统服务进程的代码。" class="headerlink" title="/fs :存放的是文件系统服务进程的代码。"></a>/fs :存放的是文件系统服务进程的代码。</h4><h5 id="fs-c：实现文件系统的基本功能函数"><a href="#fs-c：实现文件系统的基本功能函数" class="headerlink" title="fs.c：实现文件系统的基本功能函数"></a>fs.c：实现文件系统的基本功能函数</h5><blockquote><p>在文件系统服务进程中实现磁盘块与内存空间之间的映射。我们需要管理缓冲区内的内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">disk_addr</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将数据块编号转换为缓冲区范围内的对应虚拟地址 </span><span class="token keyword">int</span> <span class="token function">map_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配映射磁盘块需要的物理页面(若已经建立了映射，直接返回0)</span><span class="token keyword">void</span> <span class="token function">unmap_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放用来映射磁盘块的物理页面(not free but dirty时写回)</span><span class="token keyword">int</span> <span class="token function">dir_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在dir指向的文件控制块所代表的目录下寻找名为name的文件。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="ide-c：通过系统调用与磁盘镜像进行交互"><a href="#ide-c：通过系统调用与磁盘镜像进行交互" class="headerlink" title="ide.c：通过系统调用与磁盘镜像进行交互"></a>ide.c：通过系统调用与磁盘镜像进行交互</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> u_int <span class="token function">wait_ide_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ide_read</span><span class="token punctuation">(</span>u_int diskno<span class="token punctuation">,</span> u_int secno<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> u_int nsecs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ide_write</span><span class="token punctuation">(</span>u_int diskno<span class="token punctuation">,</span> u_int secno<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> u_int nsecs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* *  diskno: disk number. *  secno: start sector number. *  dst: destination for data read from IDE disk. *  nsecs: the number of sectors to read. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="serv-c：该进程的主干函数-文件系统服务进程的入口"><a href="#serv-c：该进程的主干函数-文件系统服务进程的入口" class="headerlink" title="serv.c：该进程的主干函数(文件系统服务进程的入口)"></a>serv.c：该进程的主干函数(文件系统服务进程的入口)</h5><p>通过IPC通信与用户进程 user/lib/fsipc.c 内的通信函数进行交互。 </p><h4 id="user-lib-存放了用户程序的库函数。"><a href="#user-lib-存放了用户程序的库函数。" class="headerlink" title="/user/lib :存放了用户程序的库函数。"></a>/user/lib :存放了用户程序的库函数。</h4><h5 id="fsipc-c：实现了与文件系统服务进程的交互-文件系统服务进程的接口"><a href="#fsipc-c：实现了与文件系统服务进程的交互-文件系统服务进程的接口" class="headerlink" title="fsipc.c：实现了与文件系统服务进程的交互(文件系统服务进程的接口)"></a>fsipc.c：实现了与文件系统服务进程的交互(文件系统服务进程的接口)</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&gt;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fsipc</span><span class="token punctuation">(</span>u_int type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>fsreq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dstva<span class="token punctuation">,</span> u_int <span class="token operator">*</span>perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h5 id="file-c：实现了文件系统的用户接口"><a href="#file-c：实现了文件系统的用户接口" class="headerlink" title="file.c：实现了文件系统的用户接口"></a>file.c：实现了文件系统的用户接口</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><img src="/2024/08/29/2024-os-lab5/img/image-20240528225824132.png" style="zoom:70%;"><img src="/2024/08/29/2024-os-lab5/img/image-20240528230547658.png" style="zoom:70%;"><h5 id="fd-c：实现了文件描述符，允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。"><a href="#fd-c：实现了文件描述符，允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。" class="headerlink" title="fd.c：实现了文件描述符，允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。"></a>fd.c：实现了文件描述符，允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。</h5><blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="磁盘驱动"><a href="#磁盘驱动" class="headerlink" title="磁盘驱动"></a>磁盘驱动</h3><p><code>ide.c</code></p><img src="/2024/08/29/2024-os-lab5/img/image-20240525012446641.png"><h3 id="文件系统的地址空间布局"><a href="#文件系统的地址空间布局" class="headerlink" title="文件系统的地址空间布局"></a>文件系统的地址空间布局</h3><img src="/2024/08/29/2024-os-lab5/img/image-20240526000321992.png"><h3 id="文件进程和用户进程的交互"><a href="#文件进程和用户进程的交互" class="headerlink" title="文件进程和用户进程的交互"></a>文件进程和用户进程的交互</h3><img src="/2024/08/29/2024-os-lab5/img/image-20240528231034014.png"><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab5文件系统需要阅读理解多个文件夹下多个代码文件，理解进程间通信及复杂嵌套一样层层的函数调用，还有文件系统本身设计的一些小巧思，理解起来真的好难（这个lab真的是感觉上最难的一个啊）。除此之外，文件系统也作为一个进程是我第一次真切体悟到MOS微内核的感觉。个人课下理解仍然不到位，导致lab5课上测试结果也并不好，os上机也结束了，虽然上机过程和结果都不算预约，但是操作系统无罪，还是得感叹操作系统真的好精妙啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab4</title>
      <link href="/2024/08/29/2024-os-lab4/"/>
      <url>/2024/08/29/2024-os-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><blockquote><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li></ul></blockquote><p><strong>系统从用户态切换到内核态后， 内核首先需要将原用户进程的运行现场保存到内核空间（在 kern/entry.S 中通过 SAVE_ALL 宏完成）。</strong>SAVE_ALL 宏只使用了k0和k1两个通用寄存器来进行操作，所以保证了其他通用寄存器的值都不会被改变。</p><blockquote><ul><li>系统陷入内核调用后可以直接从当时的 a0-a3 参数寄存器中得到用户调用 msyscall留下的信息吗？</li></ul></blockquote><p>以直接读a1-a3寄存器，但不能读a0寄存器。</p><p>从用户态调用mysyscall到读取信息发生了下述事件：<code>msyscall</code>后系统陷入内核，进入异常分发程序并跳转到<code>handle_sys</code>，后调用<code>do_syscall</code>并将sp寄存器中的值作为参数传递（更改了a0寄存器）。</p><blockquote><ul><li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？</li></ul></blockquote><p>参数通过栈传递。在内核保存现场时，这些数据都会被保存到内核栈。</p><blockquote><ul><li>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul></blockquote><p>tf-&gt;cp0_epc指向下一条指令地址，tf-&gt;regs[2]（即v0）设为异常处理函数的返回值。</p><p>程序返回用户态后能够从正确的位置继续执行，同时也使得用户程序从v0寄存器中获得<strong>系统调用的返回值</strong>。</p><h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><blockquote><p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？</p></blockquote><p>在我们生成envid时，后十位为了方便从envs数组中直接取出Env，可能会有所重叠，envid的独一性取决于mkenvid里不断增长的 i ，所以如果不判断envid是否相同，会取到错误的或者本该被销毁的进程控制块。</p><p>😊from:zy学姐</p><h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><blockquote><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与envid2env() 函数的行为进行解释。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">u_int <span class="token function">mkenvid</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">static</span> u_int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> LOG2NENV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>e <span class="token operator">-</span> envs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>mkenvid通过i确保每个进程id的唯一且非零。</p><p>在envid2env() 函数中，envid为0时表示是curenv。设置该函数中最后一个参数为1时还可以通过检查env_parent_id是不是不为0，来判断是否是子进程以完成一些只能在父子进程间发生系统调用(如销毁进程)或通信的情况。</p><h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><blockquote><p> 关于 fork 函数的两个返回值，下面说法正确的是：</p><p> A、 fork 在父进程中被调用两次，产生两个返回值</p><p> B、 fork 在两个进程中分别被调用一次，产生两个不同的返回值</p><p> C、 fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</p><p> D、 fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值 </p></blockquote><p>C</p><h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><blockquote><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。</p></blockquote><p><code>UTOP</code>和<code>UVPT</code>之间储存的是所有进程共享的pages与envs。在执行<code>env_alloc()</code>函数时，调用<code>env_setup_vm</code>初始化新进程的地址空间，这一部分的映射关系直接从<code>boot_pgdir</code>拷贝到进程页表中，不需要进行映射。</p><p><code>USTACKTOP</code>和<code>UTOP</code>之间是<strong>异常处理栈（user exception stack）和无效内存（invalid memory）</strong>，前者是进行异常处理的地方， 后者一般也不会用到，所以父子进程不需要共享这部分的内存。</p><p>所以，最终需要被映射的页面<strong>只有<code>USTACKTOP</code>之下的部分</strong>。除此之外，<code>UVPT</code>和<code>ULIM</code>之间是进程的页表，在映射USTACKTOP之下的部分时会隐式地完成子进程页表的填写，不需要显示地映射父进程的页表。</p><h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><blockquote><p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：</p></blockquote><blockquote><p>• vpt 和 vpd 的作用是什么？怎样使用它们？</p></blockquote><p><code>vpt</code>：指向用户页表基地址的指针</p><p> <mark>以vpt为基地址，加上页表项偏移数即可指向va对应的页表项，即vpt[va &gt;&gt; 12] 即 vpt[VPN(va)]；</mark> </p><p><code>vpd</code>：指向用户页目录基地址的指针</p><p>以vpd为基地址，加上页目录项偏移数即可指向va对应页目录项，即 vpd[va &gt;&gt; 22]；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//user/include/lib.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vpt</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> Pte <span class="token operator">*</span><span class="token punctuation">)</span>UVPT<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vpd</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> Pde <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>UVPT <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PGSHIFT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>• 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</p></blockquote><p>之前在lab3中实现了自映射</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">env_setup_vm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//...</span>    <span class="token comment">//lab3中实现了自映射</span><span class="token comment">/* Step 3: Map its own page table at 'UVPT' with readonly permission. * As a result, user programs can read its page table through 'UVPT' */</span>e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>• 它们是如何体现自映射设计的？</p></blockquote><p>vpd的地址在UVPT和UVPT + PDMAP之间，说明将页目录映射到了某一页表位置。一个页表都被页目录中的一个页表项所映射。因此”页目录被映射到某一个页表的位置”就意味着，<strong>在页目录中一定有一个页表项映射到了页目录本身</strong>，即实现了自映射。</p><p>😊from:hyggge</p><blockquote><p>• 进程能够通过这种方式来修改自己的页表项吗？</p></blockquote><p>不能，在<code>env_setup_vm</code>函数中对页目录只有只读权限。</p><h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><blockquote><p>在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe运行现场的过程，请思考并回答这几个问题：</p><p>• 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</p></blockquote><p>用户态的页写入异常处理函数是用户态程序自行指定的，虽然MOS中的页写入异常处理函数<code>cow_entry</code>只对异常处理栈所在的页进行了写操作，不会出现异常重入，但用户自行指定的函数却可能会发生写入COW标记页面而发生异常重入。</p><blockquote><p>• 内核为什么需要将异常的现场 Trapframe 复制到用户空间？</p></blockquote><p>异常的处理是在用户态进行的，用户态把异常处理完毕后仍然在用户态恢复现场，所以需要把内核保存的现场保存在用户空间的用户异常栈。</p><h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><blockquote><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？ </p></blockquote><p>解放内核，不用内核执行大量的页面拷贝工作；<br>内核态处理失误产生的影响较大，可能会使得操作系统崩溃；<br>用户状态下不能得到一些在内核状态才有的权限，避免改变不必要的内存空间；<br>更灵活的处理方式，可以根据具体的应用需求进行自定义的异常处理逻辑</p><h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><blockquote><p>请思考并回答以下几个问题：</p><p>• 为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？</p></blockquote><p>不是必须要把syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前，只要保证在写时复制保护机制完成之前设置好即可。</p><blockquote><p>• 如果放置在写时复制保护机制完成之后会有怎样的效果？</p></blockquote><p>父进程运行时在函数调用等情形下会修改栈。在栈空间的页面标记为写时复制之后，父进程继续运行并修改栈，就会触发 TLB Mod 异常。所以在写时复制保护机制完成之前就需要 <code>syscall_set_tlb_mod_entry</code>。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="do-syscall-函数的包装"><a href="#do-syscall-函数的包装" class="headerlink" title="do_syscall 函数的包装"></a>do_syscall 函数的包装</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// kern/genex.S</span><span class="token punctuation">.</span>macro BUILD_HANDLER exception handler<span class="token function">NESTED</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">,</span> TF_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span>move    a0<span class="token punctuation">,</span> spaddiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span>jal     \handleraddiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token number">8</span>j       ret_from_exception<span class="token function">END</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">)</span><span class="token punctuation">.</span>endm    BUILD_HANDLER sys do_syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> lab0预习教程中LEAF和NESTED的宏定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LEAF</span><span class="token expression"><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>globl  symbol<span class="token punctuation">;</span>                         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>align  <span class="token number">2</span><span class="token punctuation">;</span>                              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>type   symbol<span class="token punctuation">,</span>@function<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>ent    symbol<span class="token punctuation">;</span>                         </span><span class="token punctuation">\</span>    <span class="token expression">symbol<span class="token operator">:</span>                                 </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>frame  sp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>ra</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NESTED</span><span class="token expression"><span class="token punctuation">(</span>symbol<span class="token punctuation">,</span> framesize<span class="token punctuation">,</span> rpc<span class="token punctuation">)</span>      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>globl  symbol<span class="token punctuation">;</span>                         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>align  <span class="token number">2</span><span class="token punctuation">;</span>                              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>type   symbol<span class="token punctuation">,</span>@function<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>ent    symbol<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span>                       </span><span class="token punctuation">\</span>    <span class="token expression">symbol<span class="token operator">:</span>                                 </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>frame  sp<span class="token punctuation">,</span> framesize<span class="token punctuation">,</span> rpc</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一行是对 LEAF 宏的定义，后面括号中的 symbol 类似于函数的参数，在宏定义中的作用类似，编译时在宏中会将 symbol 替换为实际传入的文本，也即我们的函数名。</li><li>第二行中，.globl 的作用是“使标签对链接器可见”，这样即使在其它文件中也可 以引用到 symbol 标签，从而使得其它文件中可以调用我们使用宏定义声明的函数。</li><li>第三行中，.align 2 的作用是“使下面的数据进行地址对齐”，这一行语句使得下面的 symbol 标签按 4 Byte 进行对齐，从而使得我们可以使用 jal 指令跳转到这个函数（末尾拼接两位 0）。</li><li>第四行中，.type 的作用是设置 symbol 标签的类别，在这里我们设置了 symbol 标签为函数标签。</li><li>第五行中，.ent 的作用是标记每个函数的开头，需要与 .end 配对使用。这些标记使得可以在 Debug 时查看调用链</li></ul><p><code>LEAF</code> 宏和 <code>NESTED</code> 宏的区别就在于 <strong><code>LEAF</code> 宏定义的函数在被调用时没有分配栈帧的空间记录自己的“运行状态”，<code>NESTED</code> 宏在被调用时分配了栈帧的空间用于记录自己的“运行状态”</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">END</span><span class="token expression"><span class="token punctuation">(</span>function<span class="token punctuation">)</span>                       </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>end    function<span class="token punctuation">;</span>                       </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">.</span>size   function<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token operator">-</span>function</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>第一行是对 <code>END</code> 宏的定义，与上面 <code>LEAF</code> 与 <code>NESTED</code> 类似。</p></li><li><p>第二行的 <code>.end</code> 是为了与先前 <code>LEAF</code> 或 <code>NESTED</code> 声明中的 <code>.ent</code> 配对，标记了 <code>symbol</code> 函数的结束。</p></li><li><p>第三行的 <code>.size</code> 是标记了 <code>function</code> 符号占用的存储空间大小，将 <code>function</code> 符号占用的空间大小设置为 <code>.-function</code>，<code>.</code> 代表了当前地址，当前位置的地址减去 <code>function</code> 标签处的地址即可计算出符号占用的空间大小。</p></li></ul><h3 id="系统调用时用户和内核中都发生了什么"><a href="#系统调用时用户和内核中都发生了什么" class="headerlink" title="系统调用时用户和内核中都发生了什么"></a>系统调用时用户和内核中都发生了什么</h3><p><code>syscall_* </code>的函数：用户空间中最接近的内核的函数</p><p><code>sys_*</code> 的函数：内核中系统调用的具体实现部分</p><p><code>syscall_*</code>的函数与内核中的系统调用函数（<code>sys_*</code> 的函数）是一一对应的</p><p><code>syscall_*</code> 的函数的实现中，都调用了 <code>msyscall </code>函数，而且函数的第一个参数都是一个与调用名相似的宏（如SYS_print_cons），在我们的 MOS 操作系统实验中把这个参数称为<mark>系统调用号</mark> ，它们被定义在 include/syscall.h中。<mark>系统调用号</mark> 是内核区分不同系统调用的唯一依据。  </p><h4 id="debugf-和相关函数的调用关系："><a href="#debugf-和相关函数的调用关系：" class="headerlink" title="debugf 和相关函数的调用关系："></a><code>debugf</code> 和相关函数的调用关系：</h4><blockquote><p>user/lib/debugf.c</p><p><code>debugf -&gt; vdebugf -&gt; vprintfmt -&gt; debug_output -&gt; debug_flush</code></p><p>user/lib/syscall_lib.c</p><p><code>-&gt; syscall_print_cons-&gt;msyscall</code></p></blockquote><blockquote><p>kern/genex.S</p><p><code>handle_sys</code>  </p><p>kern/syscall_all.c</p><p><code>do_syscall</code></p><p>kern/syscall_all.c</p><p><code>sys_*</code>  </p></blockquote><blockquote><p>msyscall 函数一共有 6 个参数，前 4 个参数会被 syscall_* 的函数分别存入 a0-a3 寄存器（寄存器传参的部分）同时栈帧底部保留 16 字节的空间（不要求存入参数的值），后 2 个参数只会被存入在预留空间之上的 8 字节空间内（没有寄存器传参），于是总共 24 字节的空间用于参数传递。</p><p>C 代码中的这些调用过程会由编译器自动编译为汇编代码，而我们在内核中则需要显式地从保存的用户上下文中获取函数的参数值。  </p></blockquote><p>Lab3 里面中断异常处理的行为：</p><ol><li>处理器跳转到异常分发代码处(kern/entry.S)</li><li>进入异常分发程序，根据 cause 寄存器值判断异常类型并跳转到对应的处理程序(genex.S/handle_x)</li><li>处理异常，并返回</li></ol><h3 id="32个寄存器"><a href="#32个寄存器" class="headerlink" title="32个寄存器"></a>32个寄存器</h3><img src="/2024/08/29/2024-os-lab4/img/1482216155_2665-1715154845683-2.jpg"><h3 id="进程间通信Env控制块相关信息"><a href="#进程间通信Env控制块相关信息" class="headerlink" title="进程间通信Env控制块相关信息"></a>进程间通信Env控制块相关信息</h3><img src="/2024/08/29/2024-os-lab4/img/image-20240508172436630.png"><ul><li><p>int sys_ipc_recv(u_int dstva)</p></li><li><p>int sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</p><pre><code>   srcva 为 0 的调用表示只传 value 值，而不需要传递物理页面；不为 0 时，才建立两个进程的页面映射关系。</code></pre></li><li><p>进程链表相关</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1.</span> 空闲进程控制块链表env_free_list <span class="token operator">-&gt;</span> env_link获取第一个<span class="token operator">:</span> e <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_free_list<span class="token punctuation">)</span><span class="token punctuation">;</span>遍历<span class="token operator">:</span> <span class="token function">LIST_FOREACH</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env_free_list<span class="token punctuation">,</span> env_link<span class="token punctuation">)</span><span class="token punctuation">;</span>开头插入<span class="token operator">:</span> <span class="token function">LIST_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_free_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_link<span class="token punctuation">)</span><span class="token punctuation">;</span>移除<span class="token operator">:</span> <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_link<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2.</span> 调度进程队列链表env_sched_list <span class="token operator">-&gt;</span> env_sched_link获取第一个<span class="token operator">:</span> e <span class="token operator">=</span> <span class="token function">TAILQ_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">)</span><span class="token punctuation">;</span>遍历<span class="token operator">:</span> <span class="token function">TAILQ_FOREACH</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>开头插入<span class="token operator">:</span> <span class="token function">TAILQ_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>结尾插入<span class="token operator">:</span> <span class="token function">TAILQ_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>移除<span class="token operator">:</span> <span class="token function">TAILQ_REMOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fork相关"><a href="#fork相关" class="headerlink" title="fork相关"></a>fork相关</h3><h4 id="涉及函数"><a href="#涉及函数" class="headerlink" title="涉及函数"></a>涉及函数</h4><p>• kern/syscall_all.c： <code>sys_exofork</code>， <code>sys_set_env_status</code> ， <code>sys_set_tlb_mod_entry</code></p><p>• kern/tlbex.c： <code>do_tlb_mod</code> 负责完成写时复制处理<mark>前</mark>的相关设置</p><p>• user/lib/fork.c：</p><ul><li><code>fork</code></li><li><code>cow_entry</code> ：写时复制处理的函数，也是内核会从 <code>do_tlb_mod</code>返回到的函数，负责对带有 PTE_COW 标志的页面进行处理</li><li><code>duppage</code> ：父进程对子进程页面空间进行映射以及相关标志设置的函数</li></ul><h4 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h4><img src="/2024/08/29/2024-os-lab4/img/c173f9438ee35ab23a06fff417b6182.png"><p>fork函数流程：</p><img src="/2024/08/29/2024-os-lab4/img/image-20240522163904256.png"><hr><p>• user/lib/entry.S：用户进程的入口</p><p>• user/lib/libos.c：用户进程入口的 C 语言部分，负责完成执行用户程序 main 前后的准备和清理工作</p><p>• kern/genex.S：该文件实现了 MOS 的异常处理流程，虽然不是我们需要实现的重点，但是建议读者认真阅读，理解中断处理的流程。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab4-1：exam考察增加系统调用指令<br>lab4-2：exam考察父子进程之间的IPC通信，extra背景是内核控制的进程程。</p><p>感觉难点还是要熟悉系统调用的流程，准确认识到什么时候在用户态什么时候在内核态。(添加系统调用需要改变的文件一定要熟知啊)</p><p>除此之外就是掌握IPC、fork相关函数作用及对应参数的含义，以便运用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab3</title>
      <link href="/2024/08/22/2024-os-lab3/"/>
      <url>/2024/08/22/2024-os-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><p><strong>Q:</strong> 请结合MOS中的页目录自映射应用解释代码中<code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V </code>的含义。</p><p><strong>A:</strong></p><blockquote><p>指导书原文:</p><p>在两级页表中，一个进程的4GB 地址空间均映射物理内存的话，那么就需要4MB来存放页表（1024个页表），4KB来存放页目录；如果页表和页目录都在进程的地址空间中得到映射，这意味着在1024个页表中，有一个页表所对应的4MB空间就是这1024个页表占用的4MB空间。这一个特殊的页表就是页目录， 它的1024 个表项映射到这1024 个页表。因此只需要4MB的空间即可容纳页表和页目录。</p></blockquote><blockquote><p>fzy终于弄懂复述版:</p><p>一个进程的4GB地址空间均映射物理内存。</p><p>一页占据4KB地址，一个进程被分为1M个页(故需要1K个二级页表)，二级页表项组成页目录(页目录是一级页表)。所以采用页表管理机制额外存储的是二级页表，占据4MB空间。</p></blockquote><p>所有进程的地址空间都和mmu.h中的布局一致：UTOP到UVPT是所有进程共享的内核数据，UVPT 到 ULIM 当前进程的页表和页目录。</p><p>PDX(UVPT):计算存储页表的起始虚拟地址开始的4MB空间是第几个4MB，即页目录中的第几项</p><p>env_pgdir:当前进程页目录的基地址</p><p>将 <code>UVPT</code> 虚拟地址映射到页目录本身的物理地址，并设置只读权限。(自映射)</p><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><p><strong>Q:</strong> 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在64位系统中采用三级页表机制，页面大小4KB。由于64位系统中字长为 8B，且页目录也占用一页，因此页目录中有512 个页目录项，因此每级页表都需要9位。 因此在64位系统下，总共需要3×9+12=39位就可以实现三级页表机制，并不需要64 位。</p><p>现考虑上述39位的三级页式存储系统，虚拟地址空间为512GB，若三级页表的基地址为PTbase，请计算：</p><ul><li><p>三级页表页目录的基地址。 </p></li><li><p>映射到页目录自身的页目录项（自映射）。</p></li></ul><p><strong>A:</strong></p><p>PGD（页全局目录）、PMD（页中间目录）和最后一级 PTE（页表）</p><p>三级页表对应的页号：PN = PTbase &gt;&gt; 12</p><p>三级页表页目录的基地址/二级页表的基地址：PMDbase = PTbase + PN * 8 = PTbase + PTbase &gt;&gt; 9</p><p>二级页表对应的页号：PN = PMDbase &gt;&gt; 12</p><p>二级页表页目录的基地址/一级页表的基地址：PGDbase = PTbase + PN * 8 = PTbase + PTbase &gt;&gt; 9 + PTbase &gt;&gt; 18 </p><p>一级页表对应的页号：PN = PGDbase &gt;&gt; 12</p><p> 一级页表页目录的基地址/<strong>映射到页目录自身的页目录项</strong>：PTbase + PTbase &gt;&gt; 9 + PTbase &gt;&gt; 18 + PTbase &gt;&gt; 27 </p><blockquote><p>2^39B存储空间 -&gt; 一页2^12B -&gt;2^27个三级页表-&gt;2^18个二级页表-&gt;2^9个一级页表-&gt;1个一页的页目录</p><p>2^32B存储空间 -&gt; 一页2^12B -&gt;2^20个二级页表-&gt;2^10个一级页表-&gt;1个一页的页目录</p></blockquote><h3 id="Thinking3-2"><a href="#Thinking3-2" class="headerlink" title="Thinking3.2"></a>Thinking3.2</h3><p><strong>Q:</strong> elf_load_seg以函数指针的形式，接受外部自定义的回调函数map_page。 请你找到与之相关的data这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p><p><strong>A:</strong> data是在创建进程时分配的进程结构体。目的是在实现段地址映射时，获得进程的页目录和asid，区分不同进程的不同地址空间。不可以没有这个参数，否则无法正确完成地址的映射。</p><blockquote><p>&lt; VPN, ASID &gt;→&lt; PFN, N, D, V, G &gt;是TLB上的映射关系</p></blockquote><img src="/2024/08/22/2024-os-lab3/ef4f57584554c2e8893f1579a41177c.png"><h3 id="Thinking3-3"><a href="#Thinking3-3" class="headerlink" title="Thinking3.3"></a>Thinking3.3</h3><p>结合elf_load_seg的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//需加载到的虚拟地址va不对齐</span>u_long offset <span class="token operator">=</span> va <span class="token operator">-</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin<span class="token punctuation">,</span>  <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//经过处理后虚拟地址va对齐，拷贝之后的数据</span><span class="token comment">//需要拷贝的数据长度bin_size可能不页对齐，通过MIN(bin_size - i, PAGE_SIZE)处理</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> offset <span class="token operator">?</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bin_size<span class="token punctuation">;</span> i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span>    <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//bin_size &lt; sgsize需要对剩下的内存空间初始化为0</span><span class="token comment">//sgssize可能不页对齐，同理通过MIN(sgsize - i, PAGE_SIZE)处理</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sgsize<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>sgsize <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking3-4"><a href="#Thinking3-4" class="headerlink" title="Thinking3.4"></a>Thinking3.4</h3><blockquote><p>这里的 env_tf.cp0_epc 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 e_entry，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。</p></blockquote><p><strong>Q:</strong> 思考上面这一段话，并根据自己在Lab2中的理解，回答：</p><ul><li>你认为这里的env_tf.cp0_epc存储的是物理地址还是虚拟地址?</li></ul><p><strong>A:</strong> 异常程序计数器（Exception Program Counter 简称EPC）。EPC是一个 64 位可读写寄存器,其存储了异常处理完成后继续开始执行的==指令的地址==，自然是虚拟地址。</p><h3 id="Thinking3-5"><a href="#Thinking3-5" class="headerlink" title="Thinking3.5"></a>Thinking3.5</h3><blockquote><p>0号异常的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成</p><p>1号异常的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读 </p><p>2号异常的处理函数为handle_tlb，表示TLBload异常 </p><p>3号异常的处理函数为handle_tlb，表示TLBstore异常 </p><p>8号异常的处理函数为handle_sys，表示系统调用，用户进程通过执行syscall指令陷入内核</p></blockquote><p><strong>Q:</strong> 试找出0、1、2、3号异常处理函数的具体实现位置。8号异常（系统调用）涉及的do_syscall()函数将在Lab4中实现。</p><p><strong>A:</strong></p><ul><li>0号异常</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#kern/genex.SNESTED(handle_int, TF_SIZE, zero)mfc0    t0, CP0_CAUSEmfc0    t2, CP0_STATUSand     t0, t2andi    t1, t0, STATUS_IM7bnez    t1, timer_irqtimer_irq:li      a0, 0j       scheduleEND(handle_int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>1、2、3号异常</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#kern/genex.S.macro BUILD_HANDLER exception handlerNESTED(handle_\exception, TF_SIZE + 8, zero)move    a0, spaddiu   sp, sp, -8jal     \handleraddiu   sp, sp, 8j       ret_from_exceptionEND(handle_\exception).endmBUILD_HANDLER tlb do_tlb_refill#2、3号#do_tlb_refill以汇编的形式实现，位于kern/tlb_asm.cBUILD_HANDLER mod do_tlb_mod#1号#do_tlb_mod函数位于kern/tlbex.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><p><strong>Q:</strong> 阅读 entry.S、genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p><p><strong>A:</strong></p><p>entry.S:在异常处理开始后关闭中断</p><p>genex.S:异常处理结束之后开启中断</p><p>env_asm.S:运行进程开始时开启时钟中断</p><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><p><strong>Q:</strong> 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p><p><strong>A:</strong> </p><p>要进行进程切换，包括以下几种情况：</p><p>• 尚未调度过任何进程（curenv 为空指针）；</p><p>• 当前进程已经用完了时间片；</p><p>• 当前进程不再就绪（如被阻塞或退出）；</p><p>• yield 参数指定必须发生切换。</p><p>无需进行切换时，我们只需要将剩余时间片长度 count 减去 1，然后调用 env_run 函数，继续运行当前进程 curenv。在发生切换的情况下，我们还需要判断当前进程是否仍然就绪，如果是则将其移动到调度链表的尾部。之后，我们选中调度链表首部的进程来调度运行，将剩余时间片长度设置为其优先级。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>进程初始化流程、使用的函数及调用关系</li></ul><blockquote><p>void env_init</p><blockquote><p>static void map_segment</p></blockquote></blockquote><blockquote><p>struct Env *env_create</p><blockquote><p>int env_alloc</p><blockquote><p>int env_setup_vm:初始化新进程的地址空间</p></blockquote></blockquote><blockquote><p>static void load_icode</p><blockquote><p>const Elf32_Ehdr *elf_from</p><p>int elf_load_seg</p><blockquote><p>static int load_icode_mapper</p></blockquote></blockquote></blockquote></blockquote><ul><li>进程运行使用的函数及调用关系</li></ul><blockquote><p>void env_run(struct Env *e)</p><blockquote><p>void env_pop_tf(struct Trapframe *tf, u_int asid)</p></blockquote></blockquote><h4 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h4><p>当且仅当 EXL 被设置为 0 且 UM 被设置为 1 时，处理器处于用户模式，其它所有情况下，处理器均处于内核模式下。每当异常发生的时候，EXL 会被自动设置为 1，并由异常处理程序负责后续处理。而每当执行 eret 指令时，EXL 会被自动设置为 0 。</p><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>由于发生异常执行exc_gen_entry通过SAVE_ALL将当前进程的栈指针存在KSTACKTOP以保存当前进程上下文 ，后跳转到相应的异常处理程序，下以时钟中断为例。跳转到handle_int后，如果是时钟中断，执行schedule函数，判断是否需要更换进程，最后调用env_run。在env_run中，保存当前进程上下文 (如果当前没有运行的进程就跳过这一步)，恢复要启动的进程的上下文，然后运行该进程。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>很容易在作业过程中忘记函数之间的调用关系和作用，作业过程中往往就把关注点只放在了当前函数，需要在完成之后对照指导书中<strong>Lab3</strong> 在 <strong>MOS</strong> 中的概况梳理流程。</p><h3 id="课上实验"><a href="#课上实验" class="headerlink" title="课上实验"></a>课上实验</h3><p>lab3课上实验只看到了exam，与extra还未谋面TAT</p><p>exam里要求我们记录<code>env_runs</code>,<code>env_scheds</code>,<code>env_clocks</code>，第一个已经课程组给的代码中完成，第二个只需要在env结构体中添加这个变量并在schedule函数中++予以记录即可，问题主要出在env_clocks的记录。</p><img src="/2024/08/22/2024-os-lab3/image-20240425092456796.png" style="zoom:50%;"><p>会发现所有的CP0寄存器都在这个<code>cp0regdef.h</code>中被定义，可以用mfc0直接读取。根据课程组的提示我们修改<code>include/stackframe.h</code>、<code>include/trap.h</code>(一定要记得修改TF_SIZE)，以及需要注意结构体中的变量顺序要和栈的宏定义顺序一致。</p><img src="/2024/08/22/2024-os-lab3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-25%20100807.png"><img src="/2024/08/22/2024-os-lab3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-25%20100756.png"><p>上述内容应该就是本次exam最大的思维量了（课程组最最最后提示也把这里的源码给了），我迟迟没有通过的原因还是对schedule函数了解不够清晰，env_clocks没有在正确的时候更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab2</title>
      <link href="/2024/08/22/2024-os-lab2/"/>
      <url>/2024/08/22/2024-os-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p><strong>Q:</strong> 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS汇编程序中lw和sw指令使用的地址被视为虚拟地址，还是物理地址？</p><p><strong>A:</strong> 均为虚拟地址</p><blockquote><p>在实际程序中，访存、跳转等指令以及用于取指的PC寄存器中的访存目标地址都是虚拟地址。我们编写的C程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。</p></blockquote><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p><strong>Q:</strong> 请思考下述两个问题：</p><p>• 从可重用性的角度，阐述用宏来实现链表的好处。 </p><p><strong>A:</strong> 指导书中讲“C语言并没有泛型的语法，因此需要通过宏另辟蹊径来实现泛型”。</p><blockquote><p>泛型：泛型是 Java SE5 出现的新特性，泛型的本质是<strong>类型参数化或参数化类型</strong>，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。</p></blockquote><p>所以用宏实现链表可以容易地创建某个数据类型的链表，只需要在使用宏时传入对应的数据类型名称即可。故可重用性极高。</p><p>• 查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</p><p><strong>A:</strong></p><p>双向链表：在插入和删除节点时，由于每个节点都有指向前一个节点的指针，可以直接定位目标节点的前一个节点，时间复杂度为O(1)。</p><blockquote><p>/usr/include/sys/queue.h包含以下几种数据结构：</p><ol><li>双链表（List）</li><li>单链表（Singly-linked List）</li><li>单链尾队列（Singly-linked Tail queue）</li><li>简单队列（Simple queue）</li><li>双链尾队列（Tail queue）</li><li>循环队列（Circular queue）</li></ol></blockquote><img src="/2024/08/22/2024-os-lab2/lab2-2.2-1.png" style="zoom:50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-2.png" style="zoom: 50%;"><p>单向链表：对于单纯的插入和删除操作只有O(1)的时间复杂度。但是单向链表在插入和删除节点时，需要遍历链表找到目标节点的前一个节点，因此时间复杂度为O(n)。</p><img src="/2024/08/22/2024-os-lab2/lab2-2.2-3.png" style="zoom: 50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-4.png" style="zoom:50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-5.png" style="zoom:50%;"><p>循环链表：</p><ul><li><p>单向循环链表：需要遍历链表找到目标节点的前一个节点，时间复杂度会为O(n)。</p></li><li><p>双向循环链表：每个节点都有指向前一个节点和下一个节点的指针，时间复杂度会为O(1)。</p></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><p><strong>Q:</strong> 请阅读include/queue.h以及include/pmap.h,将Page_list的结构梳 理清楚，选择正确的展开结构。</p><p><strong>A:</strong> C</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                         <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  <span class="token comment">/* next element */</span>                     <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> <span class="token comment">/* address of previous next element */</span>         <span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>        u_short pp_ref<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token operator">*</span>lh_fist<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//pmap.h</span><span class="token function">LIST_HEAD</span><span class="token punctuation">(</span>Page_list<span class="token punctuation">,</span> Page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//queue.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span class="token comment">//pmap.h</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span>Page_LIST_entry_t pp_link<span class="token punctuation">;</span> <span class="token comment">/* free list link */</span><span class="token comment">// Ref is the count of pointers (usually in page table entries)</span><span class="token comment">// to this page.  This only holds for pages allocated using</span><span class="token comment">// page_alloc.  Pages allocated at boot time using pmap.c's "alloc"</span><span class="token comment">// do not have valid reference count fields.</span>u_short pp_ref<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//pmap.h</span><span class="token keyword">typedef</span> <span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Page<span class="token punctuation">)</span> Page_LIST_entry_t<span class="token punctuation">;</span><span class="token comment">//queue.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  </span><span class="token comment">/* next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p><strong>Q:</strong> 请思考下面两个问题：</p><p>• 请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID 的必要性。 </p><p><strong>A:</strong> 在多进程操作系统中，每个进程都有自己独立的虚拟地址空间，ASID可以帮助区分不同进程的TLB缓存条目。这样，当操作系统切换上下文到另一个进程时，可以清除或刷新TLB中与上一个进程相关的转换信息，避免出现地址空间混乱。</p><p>• 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳 不同的地址空间的最大数量。</p><p><strong>A:</strong> 在 MIPS 4Kc 中，ASID 段有8位，那么它可以容纳的不同地址空间的最大数量为 2^8</p><h3 id="Thinking2-5"><a href="#Thinking2-5" class="headerlink" title="Thinking2.5"></a>Thinking2.5</h3><p><strong>Q:</strong> 请回答下述三个问题： </p><p>•tlb_invalidate和tlb_out的调用关系？ </p><p><strong>A:</strong> tlb_invalidate调用tlb_out，tlb_out是叶子函数</p><p>•请用一句话概括tlb_invalidate的作用。 </p><p><strong>A:</strong> 删除某个虚拟地址在 TLB 中的旧表项。</p><p>•逐行解释tlb_out中的汇编代码。</p><p><strong>A:</strong></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LEAF(tlb_out).set noreordermfc0    t0, CP0_ENTRYHI#存储原有的EnryHi寄存器的值到$t0,用于函数结束时恢复mtc0    a0, CP0_ENTRYHI#将传入的参数设置为EnryHi新的值noptlbp#根据EntryHi中的Key(包含VPN与ASID)，查找 TLB 中与之对应的表项，并将表项的索引存入Index寄存器nopmfc0    t1, CP0_INDEX#将tlbp的执行后Index寄存器的结果保存到$t1.set reorderbltz    t1, NO_SUCH_ENTRY#Index寄存器中值小于0,表示没有查到该表项.set noreordermtc0    zero, CP0_ENTRYHImtc0    zero, CP0_ENTRYLO0mtc0    zero, CP0_ENTRYLO1#将三个寄存器中的值置零方便清空noptlbwi#以Index寄存器中的值为索引，将此时EntryHi与EntryLo0、EntryLo1的值写到索引指定的TLB表项中.set reorderNO_SUCH_ENTRY:mtc0    t0, CP0_ENTRYHI#恢复调用前EnryHi寄存器的值j       ra#跳回END(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p><strong>Q:</strong> 从下述三个问题中任选其一回答： </p><p>• 简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS在内存管理上的区别。 </p><p>• 简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上的区别。 </p><p>• 简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</p><blockquote><p>RISC-V 与 MIPS 在内存管理上的区别</p></blockquote><p>RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</p><blockquote><p> RISC-V 内存管理机制</p></blockquote><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>内存布局定义在/kernel/include/mm/memlayout.h当中</p><p>具体内存表如下</p><h5 id="S-Mode内核地址空间布局"><a href="#S-Mode内核地址空间布局" class="headerlink" title="S-Mode内核地址空间布局"></a>S-Mode内核地址空间布局</h5><pre class="line-numbers language-none"><code class="language-none">VA_MAX ----------------&gt;+---------------------------+-------0x7f ffff ffff                        |       TRAMPOLINE          |       BY2PGTRAMPOLINE ------------&gt;+---------------------------+-----------------                        |                           |PHYSICAL_MEMORY_END ---&gt;+---------------------------+-------0x8800 0000                        |                           |kernelEnd -------------&gt;+---------------------------+-----------------                        |       Kernel Data         |textEnd ---------------&gt;+---------------------------+-----------------                        |       Kernel Text         |BASE_ADDRESS, ---------&gt;+---------------------------+-------0x8020 0000kernelStart -/          |                           |                        |       OpenSBI             |PHYSICAL_MEMORY_BASE --&gt;+---------------------------+-------0x8000 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       VIRTIO              |VIRTIO ----------------&gt;+---------------------------+-------0x1000 1000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       UART0               |UART0 -----------------&gt;+---------------------------+-------0x1000 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       PILC                |PILC  -----------------&gt;+---------------------------+-------0x0c00 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       CLINT               |CLINT -----------------&gt;+---------------------------+-------0x0200 0000                        |       invalid memory      |0 ---------------------&gt;+---------------------------+-------0x0000 0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="U-Mode用户地址空间布局"><a href="#U-Mode用户地址空间布局" class="headerlink" title="U-Mode用户地址空间布局"></a>U-Mode用户地址空间布局</h5><img src="/2024/08/22/2024-os-lab2/lab2-Umode.png" style="zoom:50%;"><h4 id="虚拟页式管理（Sv39内存布局）"><a href="#虚拟页式管理（Sv39内存布局）" class="headerlink" title="虚拟页式管理（Sv39内存布局）"></a>虚拟页式管理（Sv39内存布局）</h4><h5 id="39位有效VA"><a href="#39位有效VA" class="headerlink" title="39位有效VA"></a>39位有效VA</h5><p>根据SV-39的约定，对于一个64位的虚拟地址，只使用其低39位来进行地址转换，而高25位不做使用，未来Risc-V有可能用来定义更多的翻译级别。</p><aside> 💡 因此该布局下最大的虚拟地址即为(1&lt;&lt;39)-1，也就是0x7f ffff <h5 id="三级页表机制"><a href="#三级页表机制" class="headerlink" title="三级页表机制"></a>三级页表机制<p>Sv39为页式的内存管理，每一页的大小为4kb，即4096bytes。采用三级页表来完成虚拟地址到物理地址的映射。</p></h5><h5 id="satp寄存器"><a href="#satp寄存器" class="headerlink" title="satp寄存器"></a>satp寄存器</h5><p>satp(Supervisor Address Translation and Protection)寄存器是Risc-V架构下的一个特权寄存器，用来告知cpu根页表的地址，其具体布局如下</p><table><thead><tr><th>63-60</th><th>59-44</th><th>43-0</th></tr></thead><tbody><tr><td>mode</td><td>asid</td><td>ppn</td></tr></tbody></table><ul><li>mode用来表示内存布局，这里我们设置为8，告知cpu我们采取Sv-39内存布局方式</li><li>asid为地址空间的id（暂时先不管）</li><li>ppn为页表基地址的物理页号，由于一页大小为4kb，因此即为页表的物理地址右移12位即可</li></ul><h5 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h5><p>Sv-39的虚拟地址和物理地址格式如下</p><img src="/2024/08/22/2024-os-lab2/lab2-risc-v-va-pa.png"><p>对于一个虚拟地址而言，VPN[2]为第一级页号，查询过程如下：</p><ul><li>satp寄存器存储了根页表的物理地址，将根页表的物理地址加上页表项大小（8bytes）*第一级页号即可找到其对应表项。</li><li>表项的布局如上图（Sv39 page table entry），其53-10位为下一级页表（第二级页表）的页号，低10位用作标记位</li><li>由此获得了第二级页表的基地址（页号左移12位），此时再用VPN[1]去查询第三级页表的基地址即可。</li><li>如此获得第三级页表项，其存储的页号即为最终对应的物理页号，将其左移12位再加上page offset，就得到了对应的物理地址</li></ul><img src="/2024/08/22/2024-os-lab2/lab2-va2pa.png"><h6 id="页表项的标记位"><a href="#页表项的标记位" class="headerlink" title="页表项的标记位"></a>页表项的标记位</h6><img src="/2024/08/22/2024-os-lab2/lab2-%E9%A1%B5%E8%A1%A8%E9%A1%B9%E6%A0%87%E8%AE%B0%E4%BD%8D.png"><p>上述过程已经可以查询到对应的物理地址，但页表项中的标记位也携带了一些额外的信息，下面加以解释</p><ul><li>RSW: Reserved for use by Supervisor softWare</li><li>D: Dirty bit<ul><li>exception: a virtual page is written and the D bit is clear</li></ul></li><li>A: Accessed bit<ul><li>exception: a virtual page is accessed and the A bit is clear</li></ul></li><li>可以将DA 总是设置为 1避免产生上述异常（存疑，qs文档）</li><li>U: User mode bit<ul><li>U-mode 访问许可位</li><li>S-mode <em>一般</em> 不可访问</li></ul></li><li>For non-leaf PTEs, the D, A, and U bits are reserved for future standard use</li><li>R: Read bit</li><li>W: Write bit</li><li>X: eXecute bit</li><li>RWX 具体作用见下</li><li>V: Valid bit<ul><li>有效位</li></ul></li></ul><p>在 RISC-V 中，PTE 有两种：</p><ul><li>叶 PTE：指向一个物理页 PPN</li><li>非叶 PTE：指向一个页表 PPN</li></ul><p>实际上位于任何级的 PTE 都可能成为叶 PTE，也就是不通过三级页表映射就查询到一个物理地址（RX非0）。非最低级的 PTE 作为叶 PTE 时则会形成超级页。</p><p>例如，如果第一级页表所查询到的页表项的R位或X位非0，则页表项中的PPN[2]即为物理地址的页号，而此时其一页的大小也对应的为$2^{12+9+9}=2^{30}$bits（此时PPN[1]和PPN[0]都为0，否则抛出异常），也就是1GB，这就是一个超级页。因此Sv-39下页的大小可能为4Kb，2Mb和1Gb。</p><img src="/2024/08/22/2024-os-lab2/lab2-RXW.png"><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h3><p>在  include/pmap.h 、 include/mmu.h 中： </p><ul><li>PDX(va) ：页目录偏移量（查找遍历页表时常用） </li><li>PTX(va) ：页表偏移量（查找遍历页表时常用） </li><li>PTE_ADDR(pte) ：获取页表项中的物理地址（读取 pte 时常用） </li><li>PADDR(kva) ：kseg0 处虚地址  →  物理地址 </li><li>KADDR(pa) ：物理地址  →  kseg0 处虚地址（读取 pte 后可进行转换） </li><li>va2pa(Pde *pgdir, u_long va) ：查页表，虚地址  →  物理地址（测试时常用）</li><li>pa2page(u_long pa) ：物理地址  →  页控制块（读取 pte 后可进行转换） </li><li>page2pa(struct Page *pp) ：页控制块  →  物理地址（填充 pte 时常用）</li></ul><h3 id="1-MIPS4Kc内存映射布局"><a href="#1-MIPS4Kc内存映射布局" class="headerlink" title="1.MIPS4Kc内存映射布局"></a>1.MIPS4Kc内存映射布局</h3><table><thead><tr><th></th><th>虚拟地址</th><th>物理地址</th><th>访问方式</th><th>用途</th></tr></thead><tbody><tr><td>kseg2</td><td>0xc00000000xffffffff</td><td>通过 TLB 转换成物理地址</td><td>通过cache 访存</td><td></td></tr><tr><td>kseg1</td><td>0xa0000000~0xbfffffff</td><td>虚拟地址的最高 3 位置 0</td><td>不通过cache 访存</td><td>可以用于访问外设</td></tr><tr><td>kseg0</td><td>0x80000000~0x9fffffff</td><td>虚拟地址的最高位置0</td><td>通过cache 访存</td><td>用于存放内核代码与数据</td></tr><tr><td>kuseg</td><td>0x00000000~0x7fffffff</td><td>通过 TLB 转换成物理地址</td><td>通过cache 访存</td><td>用于存放用户程序代码与数据</td></tr></tbody></table><h3 id="2-物理内存的管理方法（链表法）"><a href="#2-物理内存的管理方法（链表法）" class="headerlink" title="2.物理内存的管理方法（链表法）"></a>2.物理内存的管理方法（链表法）</h3><p>为了使用链表，我们需要定义两个结构 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code>。前者表示链表头或链表本身的类型，后者表示链表中元素的类型。通过宏定义可知，<code>LIST_HEAD(name, type)</code> 表示创建一个元素类型为 <code>type</code> 的链表，这个链表类型名为 <code>name</code>。<code>LIST_ENTRY(type)</code> 表示创建一个类型为 <code>type</code> 的链表元素。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  </span><span class="token comment">/* next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-虚拟内存的管理方法（两级页表）"><a href="#3-虚拟内存的管理方法（两级页表）" class="headerlink" title="3.虚拟内存的管理方法（两级页表）"></a>3.虚拟内存的管理方法（两级页表）</h3><p>指导书如是说：</p><blockquote><p>MOS中用PADDR 与KADDR 这两个宏可以对位于kseg0 的虚拟地址和对应的物理地址进行转换。 但是，对于位于kuseg 的虚拟地址，MOS中采用两级页表结构对其进行地址转换。</p></blockquote><p>提及函数及作用：</p><h4 id="int-pgdir-walk-Pde-pgdir-u-long-va-int-creat-Pte-ppte"><a href="#int-pgdir-walk-Pde-pgdir-u-long-va-int-creat-Pte-ppte" class="headerlink" title="int pgdir_walk(Pde *pgdir, u_long va, int creat, Pte **ppte)"></a>int pgdir_walk(Pde *pgdir, u_long va, int creat, Pte **ppte)</h4><p>将一级页表基地址pgdir对应的两级页表结构中va虚拟地址所在的二级页表项的指针 存储在 ppte指向的空间上。</p><blockquote><p>/* 将 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上<br>       *ppte = va 虚拟地址所在的二级页表项的指针<br>             = 二级页表基地址（指向二级页表的指针） + va所对的二级页表项在二级页表的偏移</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span>ppte <span class="token operator">=</span> <span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>二级页表基地址（指向二级页表的指针）：        页目录项     <span class="token operator">-&gt;</span>   二级页表的物理地址     <span class="token operator">-&gt;</span>     二级页表的虚拟地址           <span class="token operator">-&gt;</span>         指向二级页表的指针<span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span> 到 <span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span> 到 <span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span> 到 <span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span>va所对的二级页表项在二级页表的偏移： <span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p> * Post-Condition:</p><p> *  If we’re out of memory, return -E_NO_MEM.</p><p> *  Otherwise, we get the page table entry, store</p><p> *  the value of page table entry to *ppte, and return 0, indicating success.</p></blockquote><h4 id="int-page-insert-Pde-pgdir-u-int-asid-structPage-pp-u-long-va-u-int-perm"><a href="#int-page-insert-Pde-pgdir-u-int-asid-structPage-pp-u-long-va-u-int-perm" class="headerlink" title="int page_insert(Pde *pgdir,u_int asid,structPage *pp,u_long va,u_int perm)"></a>int page_insert(Pde *pgdir,u_int asid,structPage *pp,u_long va,u_int perm)</h4><p>将一级页表基地址pgdir对应的两级页表结构中虚拟地址va映射到页控制块pp对应的物理页面，并将页表项权限为设置为perm。</p><blockquote><p> * Post-Condition:</p><p> *  Return 0 on success</p><p> *  Return -E_NO_MEM, if page table couldn’t be allocated</p></blockquote><blockquote><p>If there is already a page mapped at <code>va</code>, call page_remove() to release this mapping.</p></blockquote><h4 id="struct-Page-page-lookup-Pde-pgdir-u-long-va-Pte-ppt"><a href="#struct-Page-page-lookup-Pde-pgdir-u-long-va-Pte-ppt" class="headerlink" title="struct Page *page_lookup(Pde *pgdir,u_long va,Pte **ppt)"></a>struct Page *page_lookup(Pde *pgdir,u_long va,Pte **ppt)</h4><p>返回一级页表基地址pgdir对应的两级页表结构中虚拟地址va映射的物理页面的页控制块，同时将ppte指向的空间设为对应的二级页表项地址。</p><p>就是里面有一个pgdir_walk，多一步把va经过页表查询得到的pa转化成Page结构体然后返回。</p><h4 id="void-page-remove-Pde-pgdir-u-intasid-u-longva"><a href="#void-page-remove-Pde-pgdir-u-intasid-u-longva" class="headerlink" title="void page_remove(Pde*pgdir,u_intasid,u_longva)"></a>void page_remove(Pde*pgdir,u_intasid,u_longva)</h4><p>删除一级页表基地址 pgdir对应的两级页表结构中虚拟地址va对物理地址的映射。如果存在这样的映射，那么对应 物理页面的引用次数会减少一次。</p><p>注：一级页表项的指针（Pde*）和二级页表项的指针（Pte*）的值都是虚拟地址，对他们取值后是为其分配的物理地址。</p><h3 id="4-TLB清除与重填的流程"><a href="#4-TLB清除与重填的流程" class="headerlink" title="4.TLB清除与重填的流程"></a>4.TLB清除与重填的流程</h3><p>tlbr：以 Index 寄存器中的值为索引，读出TLB中对应的表项到EntryHi与EntryLo0、EntryLo1。</p><p>tlbwi：以 Index 寄存器中的值为索引，将此时EntryHi与EntryLo0、EntryLo1 的值写到索引指定的TLB表项中。</p><p>tlbwr：将 EntryHi 与 EntryLo0、EntryLo1 的数据随机写到一个 TLB 表项中（此处使用Random 寄存器来“随机”指定表项，Random寄存器本质上是一个不停运行的循环计数器）</p><p>tlbp：根据EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将表项的索引存入Index 寄存器（若未找到匹配项，则Index最高位被置1）</p><h3 id="5-叶子函数和非叶子函数"><a href="#5-叶子函数和非叶子函数" class="headerlink" title="5.叶子函数和非叶子函数"></a>5.叶子函数和非叶子函数</h3><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><h3 id="lab2-exam"><a href="#lab2-exam" class="headerlink" title="lab2-exam"></a>lab2-exam</h3><p><strong>题目概要：</strong>统计所有二级页表项中，其对应的物理页框的引用数目大于某个值的二级页表项数目。</p><p><strong>主要思路：</strong></p><p>利用zy学姐博客中的对所有二级页表项的遍历方法，只需完善if判断条件：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//统计满足条件的页表项的数量</span>Pde <span class="token operator">*</span>pde<span class="token punctuation">;</span>Pte <span class="token operator">*</span>pte<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>pde <span class="token operator">=</span> pgdir <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pde <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//当前页目录是否有效</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span>Pte<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pde<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">////当前页表是否有效</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*if判断条件*/</span>           count<span class="token operator">++</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lab2-extra"><a href="#lab2-extra" class="headerlink" title="lab2-extra"></a>lab2-extra</h3><p><strong>题目概要：</strong>简易版伙伴系统(第一眼还以为是21年那个很难很难的考题)</p><p>伙伴系统将高地址划32MB分为数个内存区间，每个内存区间有两种状态：已分配和未分配。每个内存区间的大小只可能是 4KB和8KB。初始，32MB均被化为8KB的内存区间且状态均为未分配。buddy_free_list[0]链表中为存储大小为4KB的空闲空间，buddy_free_list[1]链表中存储大小为8KB的空闲空间。要求实现分配函数 <code>buddy_alloc</code> 和释放函数 <code>buddy_free</code></p><p><strong>主要思路：</strong></p><p>分配函数 <code>buddy_alloc</code> ：由于只有两种分配空间大小的选择，所以逻辑很简单。</p><p>释放函数 <code>buddy_free</code>：释放8KB的空间时直接释放，释放4KB的空间时需要遍历buddy_free_list[0]寻找伙伴是否空闲：空闲需要合并后插入buddy_free_list[1]，否则直接插入buddy_free_list[0]。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://yanna-zy.gitee.io/2023/04/10/BUAA-OS-2/#post-comment">https://yanna-zy.gitee.io/2023/04/10/BUAA-OS-2/#post-comment</a></li><li><a href="https://zhuanlan.zhihu.com/p/626899526">RISC-V Sv39 虚拟内存总结 - 知乎 (zhihu.com)</a></li></ol><!--39)-1，也就是0x7f--></aside>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab1</title>
      <link href="/2024/08/22/2024-os-lab1/"/>
      <url>/2024/08/22/2024-os-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p><strong>Q:</strong> 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、 ld、 readelf、 objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。  </p><p><strong>A:</strong></p><blockquote><p>上方为只经过编译的文件的反汇编结果</p><p>下方为经过编译和链接之后的文件的反汇编结果</p></blockquote><ul><li><p>x86工具链(重复附录中的操作)</p><img src="/2024/08/22/2024-os-lab1/lab1-x86.png" style="zoom:10%;"></li><li><p>MIPS交叉编译工具链</p></li></ul><img src="/2024/08/22/2024-os-lab1/lab1-mips.png" style="zoom:30%;"><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">~/test_lab1 $ mips-linux-gnu-gcc -E hello.c &gt; mips_1~/test_lab1 $ mips-linux-gnu-gcc -c hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS hello.o &gt; mips_2 ~/test_lab1 $ mips-linux-gnu-gcc -o misp.out hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS mips.out &gt; mips_3  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>objdump参数含义：</p><p>-d, –disassemble        Display assembler contents of executable sections</p><p>​反汇编那些特定指令机器码的section<br>-D, –disassemble-all    Display assembler contents of all sections</p><p>​反汇编所有的section<br>​    –disassemble=<sym>  Display assembler contents from <sym><br> -S, –source             Intermix source code with disassembly<br>​    –source-comment[=<txt>] Prefix lines of source code with <txt><br> -s, –full-contents      Display the full contents of all sections requested</txt></txt></sym></sym></p></li></ul><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><p><strong>Q:</strong> 思考下述问题：</p><p>• 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。</p><p><strong>A:</strong></p><img src="/2024/08/22/2024-os-lab1/lab1-1.png" style="zoom:33%;"><img src="/2024/08/22/2024-os-lab1/lab1-2.png" style="zoom:30%;">• 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）<p><strong>A:</strong></p><p>readelf头部文件信息：</p><img src="/2024/08/22/2024-os-lab1/lab1-readelf.png" style="zoom:33%;"><p>hello头部文件信息：</p><img src="/2024/08/22/2024-os-lab1/lab1-hello.png" style="zoom:33%;"><p>系统工具readelf头部文件信息：</p><img src="/2024/08/22/2024-os-lab1/lab1-readelfpub.png" style="zoom:33%;"><p>tools/readelf/Makefile中的readelf与hello:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">readelf: main.o readelf.o<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>readelf: main.o readelf.o        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>hello: hello.c        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span> <span class="token parameter variable">-m32</span> <span class="token parameter variable">-static</span> <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello在编译链接时添加了-m32 -static -g选项，使得生成的目标文件是32位、静态链接并且包含调试信息的。32位指的是指令集架构和内存地址的位数。我们可以看到hello的头部文件信息中类别为<strong>ELF32</strong>，而默认情况下，在64位操作系统上使用 GCC 编译器生成的可执行文件通常是64位的，故我们课程组提供的 readelf 头部文件信息中类别为<strong>ELF64</strong>。</p><blockquote><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p></blockquote><p>但是在课程组提供的 readelf.c 文件中，表示 ELF 头部信息的结构体大小为32位，故课程组的 readelf 可以用来解析 hello 而不可以用来解析它自身。</p><p>如果课程组的readelf的编译方式和hello一样，即如下述形式，则readelf_temp可以解析自身。</p><img src="/2024/08/22/2024-os-lab1/lab1-readelf_temp.png" style="zoom:33%;"><p>而之所以系统工具 readelf 都能够解析，是因为 readelf 是一个通用的 ELF 文件解析工具，可以处理不同版本的 ELF 文件。当用户使用readelf命令解析一个 ELF 文件时，readelf 会根据文件的格式自动识别是 ELF32 还是 ELF64，并相应地解析文件的结构和内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//readelf.c</span><span class="token keyword">int</span> <span class="token function">is_elf_format</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf32_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span>binary<span class="token punctuation">;</span>    <span class="token keyword">return</span> size <span class="token operator">&gt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf32_Ehdr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG0 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG1 <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG2 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p><strong>Q:</strong> 在理论课上我们了解到， MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</p><p><strong>A:</strong> QEMU 模拟器支持直接加载 ELF 格式的内核，也就是说， QEMU 已经提供了 bootloader 的引导（启动）功能。 MOS 操作系统不需要再实现 bootloader的功能。在 MOS 操作系统的运行第一行代码前，我们就已经拥有一个正常的程序运行环境，内存和一些外围设备都可以正常使用。QEMU 支持加载 ELF 格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口，启动就完成了。</p><ol><li>Makefile 中使用的$(link_script) 来生成的内核</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">link_script             :<span class="token operator">=</span> kernel.lds<span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>modules<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>LD<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token parameter variable">-o</span> <span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span> <span class="token parameter variable">-N</span> <span class="token parameter variable">-T</span> <span class="token variable"><span class="token variable">$(</span>link_script<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>objects<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>kernel.lds文件中有<code>ENTRY(_start)</code>这 一行命令，这就是内核的入口</li><li><code>start.S</code>中sp寄存器设置到内核栈空间的位置上，随后跳转到mips_init函数(C语言的主函数)</li></ol><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="1-0-常用操作"><a href="#1-0-常用操作" class="headerlink" title="1.0 常用操作"></a>1.0 常用操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DS</span> 要反汇编的目标文件名 <span class="token operator">&gt;</span> 导出文本文件名 <span class="token function">file</span> 要查看类型的目标文件名 <span class="token comment">#获得文件类型</span><span class="token function">grep</span> <span class="token parameter variable">-R</span> printcharc <span class="token comment">#-R的意思是在多个子目录中找</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-1-ELF相关"><a href="#1-1-ELF相关" class="headerlink" title="1.1 ELF相关"></a>1.1 ELF相关</h3><ul><li><strong>MemSiz与FileSiz(ELF头文件中段相关信息)</strong></li></ul><blockquote><p>Offset:该段（segment）的数据相对于 ELF文件的偏移。</p><p>VirtAddr:该段最终需要被加载到内存的哪个位置。</p><p>FileSiz:该段的数据在文件中的长度。</p><p>MemSiz:该段的数据在内存中所应当占的大小。</p></blockquote><p>MemSiz永远大于等于FileSiz。若MemSiz大于FileSiz，则操作系统在加载程序的时候，会首先将文件中记录的数据加载到对应的VirtAddr处。之后，向内存中填0 ，直到该段在内存中的大小达到MemSiz为止。那么为什么MemSiz有时候会大于FileSiz 呢？这里举这样一个例子：C语言中未初始化的全局变量，我们需要为其分配内存，但它又不需要被初始化成特定数据。因此，在可执行文件中也只记录它需要占用内存(MemSiz)，但在文件中却没有相应的数据（因为它并不需要初始化成特定数据）。故而在这种情况下， MemSiz会大于FileSiz。这也解释了，为什么C语言中全局变量会有默认值0。这是因为操作系统在加载时将所有未初始化的全局变量所占的内存统一填了0。</p><ul><li><strong>ELF头部标识符</strong></li></ul><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p><h3 id="1-2-printk实现相关"><a href="#1-2-printk实现相关" class="headerlink" title="1.2 printk实现相关"></a>1.2 printk实现相关</h3><ul><li><strong>可变参数列表</strong></li></ul><p>当函数参数列表末尾有省略号时，该函数即有变长的参数表。</p><p>由于需要定位变长参数表的起始位置，函数需要含有至少一个固定参数，且变长参数必须在参数表的末尾。 </p><p>stdarg.h 头文件中为处理变长参数表定义了一组宏和变量类型如下： </p><p>va_list，变长参数表的变量类型； </p><p>va_start(va_list ap, lastarg)，用于初始化变长参数表的宏； </p><p>va_arg(va_list ap, 类型)，用于取变长参数表下一个参数的宏； </p><p>va_end(va_list ap)，结束使用变长参数表的宏。</p><ul><li><strong>回调函数</strong></li></ul><p>回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义主函数，回调函数作为参数</span>function <span class="token function">A</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token char">'我是主函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//定义回调函数</span>function <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"console.log('我是回调函数')"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//模仿耗时操作  </span><span class="token punctuation">}</span><span class="token comment">//调用主函数，将函数B传进去</span><span class="token function">A</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出结果</span>我是主函数我是回调函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-tmux操作"><a href="#1-3-tmux操作" class="headerlink" title="1.3 tmux操作"></a>1.3 tmux操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux<span class="token comment">#启动</span>tmux <span class="token builtin class-name">set</span> mouse on <span class="token comment">#嘿嘿启用鼠标</span><span class="token builtin class-name">exit</span><span class="token comment">#退出/ctrl+D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>会话</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#新建会话</span>$ tmux detach<span class="token comment">#分离会话/ctrl+b d</span>$ tmux <span class="token function">ls</span><span class="token comment"># or</span>$ tmux list-session<span class="token comment">#查看所有会话</span><span class="token comment"># 使用会话编号</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#接入会话</span><span class="token comment"># 使用会话编号</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#杀死会话</span><span class="token comment"># 使用会话编号</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#切换会话</span>$ tmux rename-session <span class="token parameter variable">-t</span> <span class="token number">0</span> <span class="token operator">&lt;</span>new-name<span class="token operator">&gt;</span><span class="token comment">#重命名会话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗口</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new-window<span class="token comment"># 新建一个指定名称的窗口</span>$ tmux new-window <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#新建窗口</span><span class="token comment"># 切换到指定编号的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-number<span class="token operator">&gt;</span><span class="token comment"># 切换到指定名称的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#切换窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗格</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 划分上下两个窗格</span>$ tmux split-window<span class="token comment"># 划分左右两个窗格</span>$ tmux split-window <span class="token parameter variable">-h</span><span class="token comment">#划分窗格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab1上机题目本身难度不大</p><ul><li>lab1-exam:更改输出格式<br>考察点在于读入具有变长参数列表的函数参数</li><li>lab1-extra:实现简化的scanf(%d %x %s %c)<br>考察点在于编写具有变长参数列表的函数，练习使用回调函数。<br>编写逻辑并不复杂，识别百分号后的输入控制符规定的格式→根据格式获取指针→由回调函数in从控制台读取参数→存入指针指向的内存区域。<br>但是很可惜，没有通过lab1-extra。原因也很可惜，主要有两个问题，第二个十分严重的问题没有来得及在课上解决。。。<br>第一个问题:判断是否有负号之后，没有再读入下一个字符。<br>第二个问题:在明晃晃的注释下我又从控制台读取了下一个字符。</li></ul><img src="/2024/08/22/2024-os-lab1/lab1-%E5%AE%9E%E9%AA%8C.png" style="zoom:33%;"><p>309行注释掉的部分是实验课上错误的实现方式，每一种case都犯了类似的错误。</p><p>希望下次会做得好一些吧</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab0</title>
      <link href="/2024/08/21/2024-os-lab0/"/>
      <url>/2024/08/21/2024-os-lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>使用add命令之前，README.txt处于<code>Untracked</code>(未跟踪的文件)；使用add命令之后，README.txt处于<code>Staged</code>(要提交的变更)；提交README.txt之后，其处于<code>Unmodified</code>；修改README.txt之后，其处于<code>Modified</code>(尚未暂存以备提交的变更)。故Modified.txt和Untracked.txt中status并不相同。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.2.png"><p>add the file: <code>git add</code></p><p>stage the file: <code>git add</code></p><p>commit: <code>git commit</code></p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><ol><li><p>代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p><p><code>git restore print.c</code> 或者 <code>git checkout -- print.c</code> (将工作区恢复为暂存区的样子)</p></li><li><p>代码文件 print.c 被错误删除后，执行了 <code>git rm print.c</code> 命令，此时应当使用什么命令将其恢复？</p><p><code>git rm print.c</code> 已将文件从暂存区删除，故先通过 <code>git reset HEAD print.c</code> 将暂存区恢复master分支的样子， 再使用 g<code>it restore print.c</code> 或者 <code>git checkout -- print.c</code></p></li><li><p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p><p><code>git rm hello.txt</code> 直接从暂存区删除文件，工作区不会做出改变</p></li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>提交三个版本之后：</p><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-1.png" style="zoom:50%;"><p>回退版本二：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-2.png" style="zoom:50%;"></p><p>通过hashcode回到版本三：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-3.png" style="zoom:50%;"></p><p><strong>!!值得注意的是：git reset –hard会将工作区、暂存区和当前分支都重置到指定的提交状态，因此会更改工作区的内容。如果有未提交的更改，这些更改会被丢弃。</strong></p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> first<span class="token builtin class-name">echo</span> second <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> third <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> forth <span class="token operator">&gt;&gt;</span> output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;</code> :重定向命令的标准输出到文件(覆盖原文件)</p><p><code>&gt;&gt;</code> :命令的输出追加到指定文件</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>command文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-1.png" style="zoom:50%;"></p><p>result文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-2.png" style="zoom:80%;"></p><p>解释说明:（可以从test文件的内容入手）<br>test给a赋值为1，给b赋值为2，给c赋值为a+b，即c的值为3；之后将c、b、a的值依次重定向输入到file1、file2、file3；接着把file1、file2、file3追加到file4；最后将file4的结果输出到result中。</p><ul><li><p>echo echo Shell Start 与 echo ‘echo Shell Start’ 效果是否有区别：没有区别</p></li><li><p>echo echo $c&gt;file1 与 echo ‘echo $c&gt;file1’ 效果是否有区别 ：有区别，前者将echo $c输出到file1中($c会替换为变量的值)，后者将字符串echo $c&gt;file1输出到标准输出($c不会被替换)。</p><p>除此之外，“ ”中的$1会被解释，而’ ‘中的$1不会被解释。</p></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h3><p>$&lt;:代表第一个依赖文件</p><p>$^:代表所有的依赖文件</p><p>$@:target内容</p><p>*.o:所有的.o文件</p><p>*.c:所有的.c文件</p><p>外层Makefile调用内层Makefile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">all: test.o funcdir<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> funcdir//进入内层文件夹gcc funcdir/function.o test.o <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>.PHONY: cleanclean:<span class="token function">rm</span> <span class="token parameter variable">-f</span> *.o <span class="token builtin class-name">test</span><span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean <span class="token parameter variable">-C</span> funcdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shell中的表达式计算"><a href="#shell中的表达式计算" class="headerlink" title="shell中的表达式计算"></a>shell中的表达式计算</h3><ul><li><p>expr 算术表达式</p><ol><li><p>运算符之间要有空格，例如：expr&lt;空格&gt;变量&lt;空格&gt;运算符&lt;空格&gt;变量。  <code>expr 2 + 3</code>, <code>c=$(expr $a + $b)</code></p></li><li><p>乘法运算符使用 *，乘法运算符前需要加 \。例如：<code>expr 2 \* 3</code></p></li></ol></li><li><p>$[算术表达式] 及 $((算术表达式)) (无格式限制)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span><span class="token number">5</span>+9<span class="token punctuation">]</span><span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">+</span><span class="token number">9</span><span class="token variable">))</span></span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$a<span class="token operator">/</span>$b<span class="token variable">))</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="shell单引号、双引号和反引号"><a href="#shell单引号、双引号和反引号" class="headerlink" title="shell单引号、双引号和反引号"></a>shell单引号、双引号和反引号</h3><p>单引号和双引号用于变量值出现空格时，比如 name=zhang san 这样执行就会出现问  题，而必须用引号括起来，比如 name=”zhang san”。</p><ul><li><p>单引号括起来的字符都是普通字符，就算特殊字符也不再有特殊含义</p></li><li><p>双引号括起来的字符中，”$“、”\“和反引号是拥有特殊含义的，”$“代表引用变量的值(如果需要在双引号中间输出”$”和反引号，则要在符号前加入转义符”\“)</p></li><li><p>反引号代表引用命令</p><p>如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和 $(命令) 是一样的</p><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">$ echo lsls$ echo `ls`code err.txt handle-ps.sh hello.c ps.out test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="sed-grep-awk"><a href="#sed-grep-awk" class="headerlink" title="sed grep awk"></a>sed grep awk</h3><ul><li><p>sed</p><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">test</span><span class="token operator">=</span>hello $ <span class="token builtin class-name">echo</span> hello WORLD <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/<span class="token variable">$test</span>/HELLO"</span> HELLO WORLD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token number">1</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token keyword">then</span>        <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span>        <span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>         <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span><span class="token keyword">fi</span><span class="token assign-left variable">f</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$n</span>+<span class="token variable">$m</span><span class="token punctuation">]</span><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">${f}</span>p"</span> err.txt <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>​lab0的考核主要针对基础工具vim、Makefile编写、shell编写及命令行使用，难度并不在于知识本身的难度，而是对知识的掌握熟知程度。指导书并没有详细给出常用指令的所有用法，需要课下作业中查阅学习更完全更准确的用法。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li><p>Ctrl+C 终止当前程序的执行</p></li><li><p>Ctrl+Z 挂起当前程序 (fg [job_spec]，job_spec:挂起编号，默认最近挂起进程)</p></li><li><p>Ctrl+D 终止输入(若正在使用shell，则退出当前 shell)</p></li><li><p>Ctrl+L 清屏</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://c.biancheng.net/view/951.html">https://c.biancheng.net/view/951.html</a></p><p><a href="https://www.cnblogs.com/zakun/p/linux-cmd-sed.html">Linux之sed命令详解 - zakun - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oopre课程总结反思</title>
      <link href="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/"/>
      <url>/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/</url>
      
        <content type="html"><![CDATA[<h3 id="oopre课程总结反思"><a href="#oopre课程总结反思" class="headerlink" title="oopre课程总结反思"></a>oopre课程总结反思</h3><h4 id="最终架构设计"><a href="#最终架构设计" class="headerlink" title="最终架构设计"></a>最终架构设计</h4><h6 id="价值体"><a href="#价值体" class="headerlink" title="价值体"></a>价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/1.jpeg" class=""><p>这一部分类所实例化的对象是完成需求需要处理的重头戏。</p><p><code>Bottle</code>类、<code>Food</code>类、<code>Equipment</code>类的属性均只是设有其基本属性及方法。<code>Adventurer</code>类除基础属性之外，为满足需求，还包括了与前三者相关的属性（一个名为xx的HashMap表示所拥有的及一个名为xxBackpack的HashMap表示所携带的  xx为bottle、food、equipment），以及名为laborers的HashMap表示所雇佣的冒险者。</p><p><strong>待改进之处</strong>：学习优秀代码之后发现，确实把与Backpack相关的属性方法从<code>Adventurer</code>类中抽离出来会更好一些。一方面<code>Adventurer</code>类中方法会大幅减少，功能形式会更接近其他价值体，另一方面代码总体架构也会更为清晰明了。</p><h6 id="非价值体"><a href="#非价值体" class="headerlink" title="非价值体"></a>非价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/2.png" class=""><p>这一部分类所实例化的对象更多的是为了辅助价值体实现需求。</p><p><code>FightLog</code>类记录每条战斗日志，<code>FightMode</code>类执行战斗日志，<code>Input</code>类中logGeneral与modeGeneral用来分别储存所有的前两者的记录。<code>Shop</code>类完成所有的冒险者与商店之间的交互。</p><p><strong>待改进之处</strong>：编写之时只是为了方便将logGeneral、modeGeneral、teamById、teamByName放在<code>Main</code>函数并传入<code>Input</code>类中作为其属性，但并没有实际的含义。在优秀代码中看到了一份应用单例模式构造一个新的<code>World</code>类的代码，我的这些确实作为只能实例化一次的游戏世界的属性会更为合理更有意义一些。</p><h6 id="历次迭代的架构调整"><a href="#历次迭代的架构调整" class="headerlink" title="历次迭代的架构调整"></a>历次迭代的架构调整</h6><p>hw2-&gt;hw3：将<code>Main</code>函数中的对不同指令的处理抽离到一个<code>Input</code>类中</p><p>hw3-&gt;hw4：增加<code>FightLog</code>类和<code>FightMode</code>类，前者用来记录战斗日志，后者用来执行日志</p><p>hw4-&gt;hw6：实现<code>Bottle</code>类和<code>Equipment</code>类的继承，及<code>Community</code>接口</p><p>hw6-&gt;hw7：在<code>Shop</code>类中实现单例模式</p><h4 id="关于Junit"><a href="#关于Junit" class="headerlink" title="关于Junit"></a>关于Junit</h4><p>值得肯定的是，编写的Junit确实帮助我找到了不少的bug，得益于它更加独立分块的单元测试和自行构造的十分简单的数据，往往十分有助于发现问题所在。</p><p>但是，更多的Junit的编写是为了通过评测机的要求，而且一般Junit的编写是一个十分让人破防的事情👉👈。并且我从控制台输入的指令写导Junit里面真的实现很不优雅(敲打)</p><h4 id="oopre学习心得体会"><a href="#oopre学习心得体会" class="headerlink" title="oopre学习心得体会"></a>oopre学习心得体会</h4><p>第一次接触面向对象编程，我最最最直观的体会主要有以下几点：</p><ol><li>它相较于面向过程要求我们有更为清晰的代码结构。从每个类中方法的构造、对实例化对象的管理，到类与类之间的继承、接口的实现，都需要仔细的考量。因而每次完成作业总要呆呆对着电脑想很久…</li><li>它要求我们每一次的迭代要“留有余地”。迭代式的作业，除了每次实现需求之外，需要合理地估计需求易变性，尽可能地让后续的操作优雅，否则很快就会迎来代码重构(×  然而，面对特定的实现目的，代码重构有时是不可避免的。适时的代码框架的修改能够改善程序的设计复杂性， 使得代码更容易理解 。</li><li>它把代码组织成类和对象的形式，每个类都有自己的属性和方法，使得代码更加模块化和可维护，同时所描述的关系和行为也更为贴近实际问题。</li></ol><h4 id="对oopre课程简单建议"><a href="#对oopre课程简单建议" class="headerlink" title="对oopre课程简单建议"></a>对oopre课程简单建议</h4><p>总体课程体验还是相当棒的，但是美中不足的一点是个人感觉还没有完全领会到应用设计模式真正的有益之处(很有可能是因为没有完全理解)，或许下次的oopre课程作业可以在这方面有更多的应用，通过实实在在的代码编写领会设计模式。</p><h4 id="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝"><a href="#再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝" class="headerlink" title="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/"></a>再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/13/hello-world/"/>
      <url>/2023/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
