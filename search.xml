<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024_OS_lab0</title>
      <link href="/2024/08/21/2024-os-lab0/"/>
      <url>/2024/08/21/2024-os-lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>使用add命令之前，README.txt处于<code>Untracked</code>(未跟踪的文件)；使用add命令之后，README.txt处于<code>Staged</code>(要提交的变更)；提交README.txt之后，其处于<code>Unmodified</code>；修改README.txt之后，其处于<code>Modified</code>(尚未暂存以备提交的变更)。故Modified.txt和Untracked.txt中status并不相同。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.2.png"><p>add the file: <code>git add</code></p><p>stage the file: <code>git add</code></p><p>commit: <code>git commit</code></p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><ol><li><p>代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p><p><code>git restore print.c</code> 或者 <code>git checkout -- print.c</code> (将工作区恢复为暂存区的样子)</p></li><li><p>代码文件 print.c 被错误删除后，执行了 <code>git rm print.c</code> 命令，此时应当使用什么命令将其恢复？</p><p><code>git rm print.c</code> 已将文件从暂存区删除，故先通过 <code>git reset HEAD print.c</code> 将暂存区恢复master分支的样子， 再使用 g<code>it restore print.c</code> 或者 <code>git checkout -- print.c</code></p></li><li><p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p><p><code>git rm hello.txt</code> 直接从暂存区删除文件，工作区不会做出改变</p></li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>提交三个版本之后：</p><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-1.png" style="zoom:50%;"><p>回退版本二：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-2.png" style="zoom:50%;"></p><p>通过hashcode回到版本三：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-3.png" style="zoom:50%;"></p><p><strong>!!值得注意的是：git reset –hard会将工作区、暂存区和当前分支都重置到指定的提交状态，因此会更改工作区的内容。如果有未提交的更改，这些更改会被丢弃。</strong></p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> first<span class="token builtin class-name">echo</span> second <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> third <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> forth <span class="token operator">&gt;&gt;</span> output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;</code> :重定向命令的标准输出到文件(覆盖原文件)</p><p><code>&gt;&gt;</code> :命令的输出追加到指定文件</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>command文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-1.png" style="zoom:50%;"></p><p>result文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-2.png" style="zoom:80%;"></p><p>解释说明:（可以从test文件的内容入手）<br>test给a赋值为1，给b赋值为2，给c赋值为a+b，即c的值为3；之后将c、b、a的值依次重定向输入到file1、file2、file3；接着把file1、file2、file3追加到file4；最后将file4的结果输出到result中。</p><ul><li><p>echo echo Shell Start 与 echo ‘echo Shell Start’ 效果是否有区别：没有区别</p></li><li><p>echo echo $c&gt;file1 与 echo ‘echo $c&gt;file1’ 效果是否有区别 ：有区别，前者将echo $c输出到file1中($c会替换为变量的值)，后者将字符串echo $c&gt;file1输出到标准输出($c不会被替换)。</p><p>除此之外，“ ”中的$1会被解释，而’ ‘中的$1不会被解释。</p></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h3><p>$&lt;:代表第一个依赖文件</p><p>$^:代表所有的依赖文件</p><p>$@:target内容</p><p>*.o:所有的.o文件</p><p>*.c:所有的.c文件</p><p>外层Makefile调用内层Makefile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">all: test.o funcdir<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> funcdir//进入内层文件夹gcc funcdir/function.o test.o <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>.PHONY: cleanclean:<span class="token function">rm</span> <span class="token parameter variable">-f</span> *.o <span class="token builtin class-name">test</span><span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean <span class="token parameter variable">-C</span> funcdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shell中的表达式计算"><a href="#shell中的表达式计算" class="headerlink" title="shell中的表达式计算"></a>shell中的表达式计算</h3><ul><li><p>expr 算术表达式</p><ol><li><p>运算符之间要有空格，例如：expr&lt;空格&gt;变量&lt;空格&gt;运算符&lt;空格&gt;变量。  <code>expr 2 + 3</code>, <code>c=$(expr $a + $b)</code></p></li><li><p>乘法运算符使用 *，乘法运算符前需要加 \。例如：<code>expr 2 \* 3</code></p></li></ol></li><li><p>$[算术表达式] 及 $((算术表达式)) (无格式限制)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span><span class="token number">5</span>+9<span class="token punctuation">]</span><span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">+</span><span class="token number">9</span><span class="token variable">))</span></span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$a<span class="token operator">/</span>$b<span class="token variable">))</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="shell单引号、双引号和反引号"><a href="#shell单引号、双引号和反引号" class="headerlink" title="shell单引号、双引号和反引号"></a>shell单引号、双引号和反引号</h3><p>单引号和双引号用于变量值出现空格时，比如 name=zhang san 这样执行就会出现问  题，而必须用引号括起来，比如 name=”zhang san”。</p><ul><li><p>单引号括起来的字符都是普通字符，就算特殊字符也不再有特殊含义</p></li><li><p>双引号括起来的字符中，”$“、”\“和反引号是拥有特殊含义的，”$“代表引用变量的值(如果需要在双引号中间输出”$”和反引号，则要在符号前加入转义符”\“)</p></li><li><p>反引号代表引用命令</p><p>如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和 $(命令) 是一样的</p><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">$ echo lsls$ echo `ls`code err.txt handle-ps.sh hello.c ps.out test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="sed-grep-awk"><a href="#sed-grep-awk" class="headerlink" title="sed grep awk"></a>sed grep awk</h3><ul><li><p>sed</p><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">test</span><span class="token operator">=</span>hello $ <span class="token builtin class-name">echo</span> hello WORLD <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/<span class="token variable">$test</span>/HELLO"</span> HELLO WORLD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token number">1</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token keyword">then</span>        <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span>        <span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>         <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span><span class="token keyword">fi</span><span class="token assign-left variable">f</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$n</span>+<span class="token variable">$m</span><span class="token punctuation">]</span><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">${f}</span>p"</span> err.txt <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>​lab0的考核主要针对基础工具vim、Makefile编写、shell编写及命令行使用，难度并不在于知识本身的难度，而是对知识的掌握熟知程度。指导书并没有详细给出常用指令的所有用法，需要课下作业中查阅学习更完全更准确的用法。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li><p>Ctrl+C 终止当前程序的执行</p></li><li><p>Ctrl+Z 挂起当前程序 (fg [job_spec]，job_spec:挂起编号，默认最近挂起进程)</p></li><li><p>Ctrl+D 终止输入(若正在使用shell，则退出当前 shell)</p></li><li><p>Ctrl+L 清屏</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://c.biancheng.net/view/951.html">https://c.biancheng.net/view/951.html</a></p><p><a href="https://www.cnblogs.com/zakun/p/linux-cmd-sed.html">Linux之sed命令详解 - zakun - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab1</title>
      <link href="/2024/08/21/2024-os-lab1/"/>
      <url>/2024/08/21/2024-os-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p><strong>Q:</strong> 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、 ld、 readelf、 objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。  </p><p><strong>A:</strong></p><blockquote><p>上方为只经过编译的文件的反汇编结果</p><p>下方为经过编译和链接之后的文件的反汇编结果</p></blockquote><ul><li><p>x86工具链(重复附录中的操作)</p><img src="/2024/08/21/2024-os-lab1/lab1-x86.png" style="zoom:10%;"></li><li><p>MIPS交叉编译工具链</p></li></ul><img src="/2024/08/21/2024-os-lab1/lab1-mips.png" style="zoom:30%;"><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">~/test_lab1 $ mips-linux-gnu-gcc -E hello.c &gt; mips_1~/test_lab1 $ mips-linux-gnu-gcc -c hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS hello.o &gt; mips_2 ~/test_lab1 $ mips-linux-gnu-gcc -o misp.out hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS mips.out &gt; mips_3  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>objdump参数含义：</p><p>-d, –disassemble        Display assembler contents of executable sections</p><p>​反汇编那些特定指令机器码的section<br>-D, –disassemble-all    Display assembler contents of all sections</p><p>​反汇编所有的section<br>​    –disassemble=<sym>  Display assembler contents from <sym><br> -S, –source             Intermix source code with disassembly<br>​    –source-comment[=<txt>] Prefix lines of source code with <txt><br> -s, –full-contents      Display the full contents of all sections requested</txt></txt></sym></sym></p></li></ul><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><p><strong>Q:</strong> 思考下述问题：</p><p>• 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。</p><p><strong>A:</strong></p><img src="/2024/08/21/2024-os-lab1/lab1-1.png" style="zoom:33%;"><img src="/2024/08/21/2024-os-lab1/lab1-2.png" style="zoom:30%;">• 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）<p><strong>A:</strong></p><p>readelf头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-readelf.png" style="zoom:33%;"><p>hello头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-hello.png" style="zoom:33%;"><p>系统工具readelf头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-readelfpub.png" style="zoom:33%;"><p>tools/readelf/Makefile中的readelf与hello:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">readelf: main.o readelf.o<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>readelf: main.o readelf.o        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>hello: hello.c        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span> <span class="token parameter variable">-m32</span> <span class="token parameter variable">-static</span> <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello在编译链接时添加了-m32 -static -g选项，使得生成的目标文件是32位、静态链接并且包含调试信息的。32位指的是指令集架构和内存地址的位数。我们可以看到hello的头部文件信息中类别为<strong>ELF32</strong>，而默认情况下，在64位操作系统上使用 GCC 编译器生成的可执行文件通常是64位的，故我们课程组提供的 readelf 头部文件信息中类别为<strong>ELF64</strong>。</p><blockquote><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p></blockquote><p>但是在课程组提供的 readelf.c 文件中，表示 ELF 头部信息的结构体大小为32位，故课程组的 readelf 可以用来解析 hello 而不可以用来解析它自身。</p><p>如果课程组的readelf的编译方式和hello一样，即如下述形式，则readelf_temp可以解析自身。</p><img src="/2024/08/21/2024-os-lab1/lab1-readelf_temp.png" style="zoom:33%;"><p>而之所以系统工具 readelf 都能够解析，是因为 readelf 是一个通用的 ELF 文件解析工具，可以处理不同版本的 ELF 文件。当用户使用readelf命令解析一个 ELF 文件时，readelf 会根据文件的格式自动识别是 ELF32 还是 ELF64，并相应地解析文件的结构和内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//readelf.c</span><span class="token keyword">int</span> <span class="token function">is_elf_format</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf32_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span>binary<span class="token punctuation">;</span>    <span class="token keyword">return</span> size <span class="token operator">&gt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf32_Ehdr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG0 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG1 <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG2 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p><strong>Q:</strong> 在理论课上我们了解到， MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</p><p><strong>A:</strong> QEMU 模拟器支持直接加载 ELF 格式的内核，也就是说， QEMU 已经提供了 bootloader 的引导（启动）功能。 MOS 操作系统不需要再实现 bootloader的功能。在 MOS 操作系统的运行第一行代码前，我们就已经拥有一个正常的程序运行环境，内存和一些外围设备都可以正常使用。QEMU 支持加载 ELF 格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口，启动就完成了。</p><ol><li>Makefile 中使用的$(link_script) 来生成的内核</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">link_script             :<span class="token operator">=</span> kernel.lds<span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>modules<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>LD<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token parameter variable">-o</span> <span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span> <span class="token parameter variable">-N</span> <span class="token parameter variable">-T</span> <span class="token variable"><span class="token variable">$(</span>link_script<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>objects<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>kernel.lds文件中有<code>ENTRY(_start)</code>这 一行命令，这就是内核的入口</li><li><code>start.S</code>中sp寄存器设置到内核栈空间的位置上，随后跳转到mips_init函数(C语言的主函数)</li></ol><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="1-0-常用操作"><a href="#1-0-常用操作" class="headerlink" title="1.0 常用操作"></a>1.0 常用操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DS</span> 要反汇编的目标文件名 <span class="token operator">&gt;</span> 导出文本文件名 <span class="token function">file</span> 要查看类型的目标文件名 <span class="token comment">#获得文件类型</span><span class="token function">grep</span> <span class="token parameter variable">-R</span> printcharc <span class="token comment">#-R的意思是在多个子目录中找</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-1-ELF相关"><a href="#1-1-ELF相关" class="headerlink" title="1.1 ELF相关"></a>1.1 ELF相关</h3><ul><li><strong>MemSiz与FileSiz(ELF头文件中段相关信息)</strong></li></ul><blockquote><p>Offset:该段（segment）的数据相对于 ELF文件的偏移。</p><p>VirtAddr:该段最终需要被加载到内存的哪个位置。</p><p>FileSiz:该段的数据在文件中的长度。</p><p>MemSiz:该段的数据在内存中所应当占的大小。</p></blockquote><p>MemSiz永远大于等于FileSiz。若MemSiz大于FileSiz，则操作系统在加载程序的时候，会首先将文件中记录的数据加载到对应的VirtAddr处。之后，向内存中填0 ，直到该段在内存中的大小达到MemSiz为止。那么为什么MemSiz有时候会大于FileSiz 呢？这里举这样一个例子：C语言中未初始化的全局变量，我们需要为其分配内存，但它又不需要被初始化成特定数据。因此，在可执行文件中也只记录它需要占用内存(MemSiz)，但在文件中却没有相应的数据（因为它并不需要初始化成特定数据）。故而在这种情况下， MemSiz会大于FileSiz。这也解释了，为什么C语言中全局变量会有默认值0。这是因为操作系统在加载时将所有未初始化的全局变量所占的内存统一填了0。</p><ul><li><strong>ELF头部标识符</strong></li></ul><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p><h3 id="1-2-printk实现相关"><a href="#1-2-printk实现相关" class="headerlink" title="1.2 printk实现相关"></a>1.2 printk实现相关</h3><ul><li><strong>可变参数列表</strong></li></ul><p>当函数参数列表末尾有省略号时，该函数即有变长的参数表。</p><p>由于需要定位变长参数表的起始位置，函数需要含有至少一个固定参数，且变长参数必须在参数表的末尾。 </p><p>stdarg.h 头文件中为处理变长参数表定义了一组宏和变量类型如下： </p><p>va_list，变长参数表的变量类型； </p><p>va_start(va_list ap, lastarg)，用于初始化变长参数表的宏； </p><p>va_arg(va_list ap, 类型)，用于取变长参数表下一个参数的宏； </p><p>va_end(va_list ap)，结束使用变长参数表的宏。</p><ul><li><strong>回调函数</strong></li></ul><p>回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义主函数，回调函数作为参数</span>function <span class="token function">A</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token char">'我是主函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//定义回调函数</span>function <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"console.log('我是回调函数')"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//模仿耗时操作  </span><span class="token punctuation">}</span><span class="token comment">//调用主函数，将函数B传进去</span><span class="token function">A</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出结果</span>我是主函数我是回调函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-tmux操作"><a href="#1-3-tmux操作" class="headerlink" title="1.3 tmux操作"></a>1.3 tmux操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux<span class="token comment">#启动</span>tmux <span class="token builtin class-name">set</span> mouse on <span class="token comment">#嘿嘿启用鼠标</span><span class="token builtin class-name">exit</span><span class="token comment">#退出/ctrl+D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>会话</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#新建会话</span>$ tmux detach<span class="token comment">#分离会话/ctrl+b d</span>$ tmux <span class="token function">ls</span><span class="token comment"># or</span>$ tmux list-session<span class="token comment">#查看所有会话</span><span class="token comment"># 使用会话编号</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#接入会话</span><span class="token comment"># 使用会话编号</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#杀死会话</span><span class="token comment"># 使用会话编号</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#切换会话</span>$ tmux rename-session <span class="token parameter variable">-t</span> <span class="token number">0</span> <span class="token operator">&lt;</span>new-name<span class="token operator">&gt;</span><span class="token comment">#重命名会话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗口</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new-window<span class="token comment"># 新建一个指定名称的窗口</span>$ tmux new-window <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#新建窗口</span><span class="token comment"># 切换到指定编号的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-number<span class="token operator">&gt;</span><span class="token comment"># 切换到指定名称的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#切换窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗格</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 划分上下两个窗格</span>$ tmux split-window<span class="token comment"># 划分左右两个窗格</span>$ tmux split-window <span class="token parameter variable">-h</span><span class="token comment">#划分窗格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab1上机题目本身难度不大</p><ul><li>lab1-exam:更改输出格式<br>考察点在于读入具有变长参数列表的函数参数</li><li>lab1-extra:实现简化的scanf(%d %x %s %c)<br>考察点在于编写具有变长参数列表的函数，练习使用回调函数。<br>编写逻辑并不复杂，识别百分号后的输入控制符规定的格式→根据格式获取指针→由回调函数in从控制台读取参数→存入指针指向的内存区域。<br>但是很可惜，没有通过lab1-extra。原因也很可惜，主要有两个问题，第二个十分严重的问题没有来得及在课上解决。。。<br>第一个问题:判断是否有负号之后，没有再读入下一个字符。<br>第二个问题:在明晃晃的注释下我又从控制台读取了下一个字符。</li></ul><img src="/2024/08/21/2024-os-lab1/lab1-%E5%AE%9E%E9%AA%8C.png" style="zoom:33%;"><p>309行注释掉的部分是实验课上错误的实现方式，每一种case都犯了类似的错误。</p><p>希望下次会做得好一些吧</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oopre课程总结反思</title>
      <link href="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/"/>
      <url>/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/</url>
      
        <content type="html"><![CDATA[<h3 id="oopre课程总结反思"><a href="#oopre课程总结反思" class="headerlink" title="oopre课程总结反思"></a>oopre课程总结反思</h3><h4 id="最终架构设计"><a href="#最终架构设计" class="headerlink" title="最终架构设计"></a>最终架构设计</h4><h6 id="价值体"><a href="#价值体" class="headerlink" title="价值体"></a>价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/1.jpeg" class=""><p>这一部分类所实例化的对象是完成需求需要处理的重头戏。</p><p><code>Bottle</code>类、<code>Food</code>类、<code>Equipment</code>类的属性均只是设有其基本属性及方法。<code>Adventurer</code>类除基础属性之外，为满足需求，还包括了与前三者相关的属性（一个名为xx的HashMap表示所拥有的及一个名为xxBackpack的HashMap表示所携带的  xx为bottle、food、equipment），以及名为laborers的HashMap表示所雇佣的冒险者。</p><p><strong>待改进之处</strong>：学习优秀代码之后发现，确实把与Backpack相关的属性方法从<code>Adventurer</code>类中抽离出来会更好一些。一方面<code>Adventurer</code>类中方法会大幅减少，功能形式会更接近其他价值体，另一方面代码总体架构也会更为清晰明了。</p><h6 id="非价值体"><a href="#非价值体" class="headerlink" title="非价值体"></a>非价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/2.png" class=""><p>这一部分类所实例化的对象更多的是为了辅助价值体实现需求。</p><p><code>FightLog</code>类记录每条战斗日志，<code>FightMode</code>类执行战斗日志，<code>Input</code>类中logGeneral与modeGeneral用来分别储存所有的前两者的记录。<code>Shop</code>类完成所有的冒险者与商店之间的交互。</p><p><strong>待改进之处</strong>：编写之时只是为了方便将logGeneral、modeGeneral、teamById、teamByName放在<code>Main</code>函数并传入<code>Input</code>类中作为其属性，但并没有实际的含义。在优秀代码中看到了一份应用单例模式构造一个新的<code>World</code>类的代码，我的这些确实作为只能实例化一次的游戏世界的属性会更为合理更有意义一些。</p><h6 id="历次迭代的架构调整"><a href="#历次迭代的架构调整" class="headerlink" title="历次迭代的架构调整"></a>历次迭代的架构调整</h6><p>hw2-&gt;hw3：将<code>Main</code>函数中的对不同指令的处理抽离到一个<code>Input</code>类中</p><p>hw3-&gt;hw4：增加<code>FightLog</code>类和<code>FightMode</code>类，前者用来记录战斗日志，后者用来执行日志</p><p>hw4-&gt;hw6：实现<code>Bottle</code>类和<code>Equipment</code>类的继承，及<code>Community</code>接口</p><p>hw6-&gt;hw7：在<code>Shop</code>类中实现单例模式</p><h4 id="关于Junit"><a href="#关于Junit" class="headerlink" title="关于Junit"></a>关于Junit</h4><p>值得肯定的是，编写的Junit确实帮助我找到了不少的bug，得益于它更加独立分块的单元测试和自行构造的十分简单的数据，往往十分有助于发现问题所在。</p><p>但是，更多的Junit的编写是为了通过评测机的要求，而且一般Junit的编写是一个十分让人破防的事情👉👈。并且我从控制台输入的指令写导Junit里面真的实现很不优雅(敲打)</p><h4 id="oopre学习心得体会"><a href="#oopre学习心得体会" class="headerlink" title="oopre学习心得体会"></a>oopre学习心得体会</h4><p>第一次接触面向对象编程，我最最最直观的体会主要有以下几点：</p><ol><li>它相较于面向过程要求我们有更为清晰的代码结构。从每个类中方法的构造、对实例化对象的管理，到类与类之间的继承、接口的实现，都需要仔细的考量。因而每次完成作业总要呆呆对着电脑想很久…</li><li>它要求我们每一次的迭代要“留有余地”。迭代式的作业，除了每次实现需求之外，需要合理地估计需求易变性，尽可能地让后续的操作优雅，否则很快就会迎来代码重构(×  然而，面对特定的实现目的，代码重构有时是不可避免的。适时的代码框架的修改能够改善程序的设计复杂性， 使得代码更容易理解 。</li><li>它把代码组织成类和对象的形式，每个类都有自己的属性和方法，使得代码更加模块化和可维护，同时所描述的关系和行为也更为贴近实际问题。</li></ol><h4 id="对oopre课程简单建议"><a href="#对oopre课程简单建议" class="headerlink" title="对oopre课程简单建议"></a>对oopre课程简单建议</h4><p>总体课程体验还是相当棒的，但是美中不足的一点是个人感觉还没有完全领会到应用设计模式真正的有益之处(很有可能是因为没有完全理解)，或许下次的oopre课程作业可以在这方面有更多的应用，通过实实在在的代码编写领会设计模式。</p><h4 id="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝"><a href="#再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝" class="headerlink" title="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/"></a>再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/13/hello-world/"/>
      <url>/2023/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
