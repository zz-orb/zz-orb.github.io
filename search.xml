<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/11/06/oopre-ke-cheng-zong-jie-fan-si/"/>
      <url>/2023/11/06/oopre-ke-cheng-zong-jie-fan-si/</url>
      
        <content type="html"><![CDATA[<h3 id="oopre课程总结反思"><a href="#oopre课程总结反思" class="headerlink" title="oopre课程总结反思"></a>oopre课程总结反思</h3><h4 id="最终架构设计"><a href="#最终架构设计" class="headerlink" title="最终架构设计"></a>最终架构设计</h4><p>######价值体</p><p><img src="/oopre%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D.assets/Adventurer-1699240454037-7.png"></p><p>这一部分类所实例化的对象是完成需求需要处理的重头戏。</p><p><code>Bottle</code>类、<code>Food</code>类、<code>Equipment</code>类的属性均只是设有其基本属性及方法。<code>Adventurer</code>类除基础属性之外，为满足需求，还包括了与前三者相关的属性（一个名为xx的HashMap表示所拥有的及一个名为xxBackpack的HashMap表示所携带的  xx为bottle、food、equipment），以及名为laborers的HashMap表示所雇佣的冒险者。</p><p><strong>待改进之处</strong>：学习优秀代码之后发现，确实把与Backpack相关的属性方法从<code>Adventurer</code>类中抽离出来会更好一些。一方面<code>Adventurer</code>类中方法会大幅减少，功能形式会更接近其他价值体，另一方面代码总体架构也会更为清晰明了。</p><h6 id="非价值体"><a href="#非价值体" class="headerlink" title="非价值体"></a>非价值体</h6><p><img src="/oopre%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D.assets/Adventurer-1699240297390-5.png" alt="Adventurer"></p><p>这一部分类所实例化的对象更多的是为了辅助价值体实现需求。</p><p><code>FightLog</code>类记录每条战斗日志，<code>FightMode</code>类执行战斗日志，<code>Input</code>类中logGeneral与modeGeneral用来分别储存所有的前两者的记录。<code>Shop</code>类完成所有的冒险者与商店之间的交互。</p><p><strong>待改进之处</strong>：编写之时只是为了方便将logGeneral、modeGeneral、teamById、teamByName放在<code>Main</code>函数并传入<code>Input</code>类中作为其属性，但并没有实际的含义。在优秀代码中看到了一份应用单例模式构造一个新的<code>World</code>类的代码，我的这些确实作为只能实例化一次的游戏世界的属性会更为合理更有意义一些。</p><h6 id="历次迭代的架构调整"><a href="#历次迭代的架构调整" class="headerlink" title="历次迭代的架构调整"></a>历次迭代的架构调整</h6><p>hw2-&gt;hw3：将<code>Main</code>函数中的对不同指令的处理抽离到一个<code>Input</code>类中</p><p>hw3-&gt;hw4：增加<code>FightLog</code>类和<code>FightMode</code>类，前者用来记录战斗日志，后者用来执行日志</p><p>hw4-&gt;hw6：实现<code>Bottle</code>类和<code>Equipment</code>类的继承，及<code>Community</code>接口</p><p>hw6-&gt;hw7：在<code>Shop</code>类中实现单例模式</p><h4 id="关于Junit"><a href="#关于Junit" class="headerlink" title="关于Junit"></a>关于Junit</h4><p>值得肯定的是，编写的Junit确实帮助我找到了不少的bug，得益于它更加独立分块的单元测试和自行构造的十分简单的数据，往往十分有助于发现问题所在。</p><p>但是，更多的Junit的编写是为了通过评测机的要求，而且一般Junit的编写是一个十分让人破防的事情👉👈。并且我从控制台输入的指令写导Junit里面真的实现很不优雅(敲打)</p><h4 id="oopre学习心得体会"><a href="#oopre学习心得体会" class="headerlink" title="oopre学习心得体会"></a>oopre学习心得体会</h4><p>第一次接触面向对象编程，我最最最直观的体会主要有以下几点：</p><ol><li>它相较于面向过程要求我们有更为清晰的代码结构。从每个类中方法的构造、对实例化对象的管理，到类与类之间的继承、接口的实现，都需要仔细的考量。因而每次完成作业总要呆呆对着电脑想很久…</li><li>它要求我们每一次的迭代要“留有余地”。迭代式的作业，除了每次实现需求之外，需要合理地估计需求易变性，尽可能地让后续的操作优雅，否则很快就会迎来代码重构(×  然而，面对特定的实现目的，代码重构有时是不可避免的。适时的代码框架的修改能够改善程序的设计复杂性， 使得代码更容易理解 。</li><li>它把代码组织成类和对象的形式，每个类都有自己的属性和方法，使得代码更加模块化和可维护，同时所描述的关系和行为也更为贴近实际问题。</li></ol><h4 id="对oopre课程简单建议"><a href="#对oopre课程简单建议" class="headerlink" title="对oopre课程简单建议"></a>对oopre课程简单建议</h4><p>总体课程体验还是相当棒的，但是美中不足的一点是个人感觉还没有完全领会到应用设计模式真正的有益之处(很有可能是因为没有完全理解)，或许下次的oopre课程作业可以在这方面有更多的应用，通过实实在在的代码编写领会设计模式。</p><p>####再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>典型语句</title>
      <link href="/2023/10/18/mips-1-dian-xing-yu-ju/"/>
      <url>/2023/10/18/mips-1-dian-xing-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>C语言与MIPS汇编语言常用语句对照<br>注：当前不考虑延迟槽 nop语句可忽略<br><del>但我先留下了 万一以后学到了还能有一丢丢印象（安详）</del><br>###条件语句</p><pre class="line-numbers language-mipsasm" data-language="mipsasm"><code class="language-mipsasm">.textli $t1, 100             #t1 = 100li $t2, 200             #t2 = 200slt $t3, $t1, $t2       #if(t1 &lt; t2) t3 = 1 beq $t3, $0, if_1_elsenop#do somethingj if_1_end              #jump to endnopif_1_else:#do something elseif_1_end:li $v0, 10syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>###循环语句</p><pre class="line-numbers language-mipsasm" data-language="mipsasm"><code class="language-mipsasm">.textli $t1, 100             #n = 100li $t2, 0               #iin_i:                   #for (int i = 0; i &lt; n; i++)beq $t2, $t1, in_i_end  #{nop      #do somethingaddi $t2, $t2, 1        #i++j in_inop                     #}  in_i_end1:li $v0, 10syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>####循环应用<br>#####一维数组<br>预处理</p><pre class="line-numbers language-none"><code class="language-none">.dataarray: .space 40           # 存储这些数需要用到数组，数组需要使用 10 * 4 = 40 字节                           # 一个 int 整数需要占用 4 个字节，需要存储 10 个 int 整数                           # 因此，array[0] 的地址为 0x00，array[1] 的地址为 0x04                           # array[2] 的地址为 0x08，以此类推。str:   .asciiz "The numbers are:\n"space: .asciiz " "<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入数组</p><pre class="line-numbers language-none"><code class="language-none">.textli $v0,5syscall                    # 输入一个整数move $s0, $v0              # $s0 is nli $t0, 0                  # $t0 循环变量loop_in:beq $t0, $s0, loop_in_end  # $t0 == $s0 的时候跳出循环li $v0, 5syscall                    # 输入一个整数sll $t1, $t0, 2            # $t1 = $t0 &lt;&lt; 2，即 $t1 = $t0 * 4sw $v0, array($t1)         # 把输入的数存入地址为 array + $t1 的内存中addi $t0, $t0, 1           # $t0 = $t0 + 1j loop_in                  # 跳转到 loop_in<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出数组</p><pre class="line-numbers language-none"><code class="language-none">loop_in_end:la $a0, strli $v0, 4syscall                    # 输出提示信息li $t0, 0loop_out:beq $t0, $s0, loop_out_endsll $t1, $t0, 2            # $t1 = $t0 &lt;&lt; 2，即 $t1 = $t0 * 4lw $a0, array($t1)         # 把内存中地址为 array + $t1 的数取出到 $a0 中li $v0, 1syscall                    # 输出 $a0la $a0, spaceli $v0, 4syscall                    # 输出一个空格addi $t0, $t0, 1j loop_outloop_out_end:li $v0, 10syscall                    # 结束程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#####二维数组<br>预处理</p><pre class="line-numbers language-none"><code class="language-none">.datamatrix: .space  256             # int matrix[8][8]   8*8*4 字节                                # matrix[0][0] 的地址为 0x00，matrix[0][1] 的地址为 0x04，……                                # matrix[1][0] 的地址为 0x20，matrix[1][1] 的地址为 0x24，……                                # ……str_enter:  .asciiz "\n"str_space:  .asciiz " "# 这里使用了宏，%i 为存储当前行数的寄存器，%j 为存储当前列数的寄存器# 把 (%i * 8 + %j) * 4 存入 %ans 寄存器中.macro  getindex(%ans, %i, %j)    sll %ans, %i, 3             # %ans = %i * 8    add %ans, %ans, %j          # %ans = %ans + %j    sll %ans, %ans, 2           # %ans = %ans * 4.end_macro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入数组</p><pre class="line-numbers language-none"><code class="language-none">.textli  $v0, 5syscallmove $s0, $v0                   # 行数li  $v0, 5syscallmove $s1, $v0                   # 列数# 这里使用了循环嵌套li  $t0, 0                      # $t0 是一个循环变量in_i:                           # 这是外层循环beq $t0, $s0, in_i_endli  $t1, 0                      # $t1 是另一个循环变量in_j:                           # 这是内层循环beq $t1, $s1, in_j_endli  $v0, 5syscall                         # 注意一下下面几行，在 Execute 页面中 Basic 列变成了什么getindex($t2, $t0, $t1)         # 这里使用了宏，就不用写那么多行来算 ($t0 * 8 + $t1) * 4 了sw  $v0, matrix($t2)            # matrix[$t0][$t1] = $v0addi $t1, $t1, 1j   in_jin_j_end:addi $t0, $t0, 1j   in_i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出数组</p><pre class="line-numbers language-none"><code class="language-none">in_i_end:# 这里使用了循环嵌套，和输入的时候同理li  $t0, 0out_i:beq $t0, $s0, out_i_endli  $t1, 0out_j:beq $t1, $s1, out_j_endgetindex($t2, $t0, $t1)lw  $a0, matrix($t2)            # $a0 = matrix[$t0][$t1]li  $v0, 1syscallla  $a0, str_spaceli  $v0, 4syscall                         # 输出一个空格addi $t1, $t1, 1j   out_jout_j_end:la  $a0, str_enterli  $v0, 4syscall                         # 输出一个回车addi $t0, $t0, 1j   out_iout_i_end:li  $v0, 10syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更具有普适性的二维数组脚标计算</p><pre class="line-numbers language-none"><code class="language-none">.macro calc_addr(%dst, %row, %column, %rank)    # dts: the register to save the calculated address    # row: the row that element is in    # column: the column that element is in    # rank: the number of lines(rows) in the matrix    multu %row, %rank    mflo %dst    addu %dst, %dst, %column    sll %dst, %dst, 2.end_macro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>####函数调用<br>为了保证函数不会对外部造成影响，我们需要正确地使用栈！<br>最基础的进栈出栈操作如下：</p><pre class="line-numbers language-none"><code class="language-none">sw $s0, 0($sp)        #进栈addi $sp, $sp, -4addi $sp, $sp, 4      #出栈lw $s3, 0($sp)```   栈在函数调用中的作用是帮助我们**保存和恢复函数使用的寄存器**，函数应该计算返回值，但不应该产生其他的负面影响。有两种使用栈的方式：- 在调用函数前--**调用者保存**- 在函数内部--**被调用者保存**|registers|Name|usage||:---:|:---:|:---:||\$0|\$zero|常量0||\$1|\$at|保留给汇编器使用的临时变量||\$2-\$3|\$v0-\$v1|函数调用返回值||\$4-\$7|\$a0-\$a3|函数调用参数||\$8-\$15|\$t0-\$t7|临时变量||\$16-\$23|\$s0-\$s7|需要保存的变量||\$24-\$25|\$t8-\$t9|临时变量||\$26-\$27|\$k0-\$k1|留给操作系统使用||\$28|\$gp|全局指针||\$29|\$sp|堆栈指针||\$30|\$fp|帧指针||\$31|\$ra|返回地址|#####嵌套函数一旦一个函数不是叶子函数（叶子函数内不会调用函数），就需要保存和恢复 $ra。#####递归函数递归函数的本质就是一个**在函数体内调用自身的嵌套函数**。同时，可以利用宏定义简化代码，提高可读性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>.macro end<br>    li      $v0, 10<br>    syscall<br>.end_macro</p><p>.macro getInt(%des)<br>    li      $v0, 5<br>    syscall<br>    move    %des, $v0<br>.end_macro</p><p>.macro printInt(%src)<br>    move    $a0, %src<br>    li      $v0, 1<br>    syscall<br>.end_macro</p><p>.macro push(%src)<br>    sw      %src, 0($sp)<br>    subi    $sp, $sp, 4<br>.end_macro</p><p>.macro pop(%des)<br>    addi    $sp, $sp, 4<br>    lw      %des, 0($sp)<br>.end_macro</p><pre class="line-numbers language-none"><code class="language-none">函数的传参和出入栈部分，写法十分的普世（对于每个函数，入口和出口都是十分固定的，都是入栈，传参，出栈，返回这四个基本流程）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>factorial:<br>    # 入栈<br>    push($ra)<br>    push($t0)<br>    # 传参<br>    move    $t0, $a0<br>    # 函数过程<br>    bne     $t0, 1, else<br>    # 基准情况<br>    if:<br>        li      $v0, 1<br>        j       if_end<br>    # 递归情况<br>    else:<br>        subi    $t1, $t0, 1<br>        move    $a0, $t1<br>        jal     factorial<br>        mult    $t0, $v0<br>        mflo    $v0<br>    if_end:<br>    # 出栈<br>    pop($t0)<br>    pop($ra)<br>    # 返回<br>    jr      $ra</p><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MIPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1课下_verilog_状态机</title>
      <link href="/2023/10/14/p1-ke-xia-verilog-zhuang-tai-ji/"/>
      <url>/2023/10/14/p1-ke-xia-verilog-zhuang-tai-ji/</url>
      
        <content type="html"><![CDATA[<p>###状态机编码风格<br>前面我们已经知道了如何使用 Verilog 语言来描述状态机。这里介绍一下状态机的典型状态编码风格，仍然使用前面的例子进行分析。状态机的编码风格有<strong>一段式（也称高速状态机）</strong>、<strong>两段式</strong>、<strong>三段式</strong>等。</p><ul><li>一段式状态机<br>一段式状态机将整个状态机编写在一个 always 模块里，该模块采用同步时序逻辑，全部使用非阻塞赋值。该模块既描述状态转移，又描述状态的输入和输出。上面的例程就是典型的一段式状态机。</li></ul><p>采用一段式状态机在思路上比较容易，书写的用时少，且运行速度快，在上机的时候可以节省编码的用时。但缺点是维护代码和调试比较困难。采用两段式和三段式状态机可以避免以上问题。</p><hr><p>示例代码</p><pre class="line-numbers language-none"><code class="language-none">module fsm_1010(     input clk,     input in,     output reg out = 0    );     integer state = 0;     /* state 被期望能够正确表示当前累计读入的 1010 前缀的长度。     比如未读入时 state=0; 读入到 10 时我们期望有 state&lt;=2。*/     always @(posedge clk) begin        case (state)        0:            begin                state &lt;= in == 1 ? 1 : 0;                out &lt;= 0;            end        1:            begin                state &lt;= in == 1 ? 1 : 2;                out &lt;= 0;            end        2:            begin                state &lt;= in == 1 ? 3 : 0;                out &lt;= 0;            end        3:            begin                state &lt;= in == 1 ? 1 : 4;                out &lt;= (in == 0);            end        4:            begin                state &lt;= in == 1 ? 3 : 0;                out &lt;= 0;            end        endcase    endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>两段式状态机<br>两段式状态机使用两个 always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块使用组合逻辑判断状态转移的条件，描述状态转移的规律。</li></ul><p>和一段式状态机相比，采用两段式状态机实现了同步时序列逻辑和组合逻辑的分离，便于阅读、理解和维护，有利于综合工具优化代码，方便用户添加时序约束条件。但缺点是编码环节多，代码量稍大，较为繁琐，因为要将其拆分成两个不同的模块。</p><hr><p>示例代码</p><pre class="line-numbers language-none"><code class="language-none">module fsm_1010 (    input clk,    input in,    output reg out);reg [2:0] state = 0;reg [2:0] next_state;// 描述状态转移的时序逻辑always @(posedge clk) begin    state &lt;= next_state; // 这里还可以视情况添加复位功能end// 判断状态转移条件以及产生输出组合逻辑always @(state, in) begin    case (state)        0:            begin                next_state = in == 1 ? 1 : 0;                out = 0;            end        1:            begin                next_state = in == 1 ? 1 : 2;                out = 0;            end        2:            begin                next_state = in == 1 ? 3 : 0;                out = 0;            end        3:            begin                next_state = in == 1 ? 1 : 4;                out = 0;            end        4:            begin                next_state = in == 1 ? 3 : 0;                out = 1;            end        default:            begin                next_state = 3;                out = 0;            end    endcaseendend module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>三段式状态机<br>三段式状态机使用三个 always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块采用组合逻辑判断状态转移条件，描述状态转移规律；第三个 always 模块采用组合逻辑或者时序逻辑述每个状态的输出。</li></ul><p>和两段式状态机相比，这样可以减少毛刺的产生（想想这是为什么）。其缺点和两段式状态机相同，编码复杂，消耗的资源也比较多，因为需要初态和次态状态寄存器等。</p><p>这是因为三段式状态机将输出分离成独立的组合逻辑，减小了关键路径和时延，所以可以减少毛刺现象。</p><hr><p>示例代码</p><pre class="line-numbers language-none"><code class="language-none">module fsm_1010 (    input clk,    input in,    output reg out);reg [2:0] state = 0;reg [2:0] next_state;// 描述状态转移的时序逻辑always @(posedge clk) begin    state &lt;= next_state;end// 判断状态转移条件的组合逻辑always @(state, in) begin    case (state)        0:            begin                next_state = in == 1 ? 1 : 0;            end        1:            begin                next_state = in == 1 ? 1 : 2;            end        2:            begin                next_state = in == 1 ? 3 : 0;            end        3:            begin                next_state = in == 1 ? 1 : 4;            end        4:            begin                next_state = in == 1 ? 3 : 0;            end        default:            begin                next_state = 3;            end    endcaseend// 产生输出的组合逻辑always @(state) begin    out = (state == 4) ? 1 : 0;endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小结<br>上面的例子是针对 Moore 状态机的，在 Mealy 状态机上也可以尝试使用这三种风格进行状态机的书写，代码框架是相同的。</p><p>同学们可以根据自身情况选用这三种不同风格的状态机，但一定要明白它们的内在区别和其中的设计原理，帮助自己在课下和上机的时候顺利完成各种状态机的书写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/13/hello-world/"/>
      <url>/2023/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/10/09/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2023/10/09/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
