<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024_OS_lab2</title>
      <link href="/2024/08/22/2024-os-lab2/"/>
      <url>/2024/08/22/2024-os-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p><strong>Q:</strong> 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS汇编程序中lw和sw指令使用的地址被视为虚拟地址，还是物理地址？</p><p><strong>A:</strong> 均为虚拟地址</p><blockquote><p>在实际程序中，访存、跳转等指令以及用于取指的PC寄存器中的访存目标地址都是虚拟地址。我们编写的C程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。</p></blockquote><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p><strong>Q:</strong> 请思考下述两个问题：</p><p>• 从可重用性的角度，阐述用宏来实现链表的好处。 </p><p><strong>A:</strong> 指导书中讲“C语言并没有泛型的语法，因此需要通过宏另辟蹊径来实现泛型”。</p><blockquote><p>泛型：泛型是 Java SE5 出现的新特性，泛型的本质是<strong>类型参数化或参数化类型</strong>，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。</p></blockquote><p>所以用宏实现链表可以容易地创建某个数据类型的链表，只需要在使用宏时传入对应的数据类型名称即可。故可重用性极高。</p><p>• 查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</p><p><strong>A:</strong></p><p>双向链表：在插入和删除节点时，由于每个节点都有指向前一个节点的指针，可以直接定位目标节点的前一个节点，时间复杂度为O(1)。</p><blockquote><p>/usr/include/sys/queue.h包含以下几种数据结构：</p><ol><li>双链表（List）</li><li>单链表（Singly-linked List）</li><li>单链尾队列（Singly-linked Tail queue）</li><li>简单队列（Simple queue）</li><li>双链尾队列（Tail queue）</li><li>循环队列（Circular queue）</li></ol></blockquote><img src="/2024/08/22/2024-os-lab2/lab2-2.2-1.png" style="zoom:50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-2.png" style="zoom: 50%;"><p>单向链表：对于单纯的插入和删除操作只有O(1)的时间复杂度。但是单向链表在插入和删除节点时，需要遍历链表找到目标节点的前一个节点，因此时间复杂度为O(n)。</p><img src="/2024/08/22/2024-os-lab2/lab2-2.2-3.png" style="zoom: 50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-4.png" style="zoom:50%;"><img src="/2024/08/22/2024-os-lab2/lab2-2.2-5.png" style="zoom:50%;"><p>循环链表：</p><ul><li><p>单向循环链表：需要遍历链表找到目标节点的前一个节点，时间复杂度会为O(n)。</p></li><li><p>双向循环链表：每个节点都有指向前一个节点和下一个节点的指针，时间复杂度会为O(1)。</p></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><p><strong>Q:</strong> 请阅读include/queue.h以及include/pmap.h,将Page_list的结构梳 理清楚，选择正确的展开结构。</p><p><strong>A:</strong> C</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                         <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  <span class="token comment">/* next element */</span>                     <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> <span class="token comment">/* address of previous next element */</span>         <span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>        u_short pp_ref<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token operator">*</span>lh_fist<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//pmap.h</span><span class="token function">LIST_HEAD</span><span class="token punctuation">(</span>Page_list<span class="token punctuation">,</span> Page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//queue.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span class="token comment">//pmap.h</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span>Page_LIST_entry_t pp_link<span class="token punctuation">;</span> <span class="token comment">/* free list link */</span><span class="token comment">// Ref is the count of pointers (usually in page table entries)</span><span class="token comment">// to this page.  This only holds for pages allocated using</span><span class="token comment">// page_alloc.  Pages allocated at boot time using pmap.c's "alloc"</span><span class="token comment">// do not have valid reference count fields.</span>u_short pp_ref<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//pmap.h</span><span class="token keyword">typedef</span> <span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Page<span class="token punctuation">)</span> Page_LIST_entry_t<span class="token punctuation">;</span><span class="token comment">//queue.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  </span><span class="token comment">/* next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p><strong>Q:</strong> 请思考下面两个问题：</p><p>• 请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID 的必要性。 </p><p><strong>A:</strong> 在多进程操作系统中，每个进程都有自己独立的虚拟地址空间，ASID可以帮助区分不同进程的TLB缓存条目。这样，当操作系统切换上下文到另一个进程时，可以清除或刷新TLB中与上一个进程相关的转换信息，避免出现地址空间混乱。</p><p>• 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳 不同的地址空间的最大数量。</p><p><strong>A:</strong> 在 MIPS 4Kc 中，ASID 段有8位，那么它可以容纳的不同地址空间的最大数量为 2^8</p><h3 id="Thinking2-5"><a href="#Thinking2-5" class="headerlink" title="Thinking2.5"></a>Thinking2.5</h3><p><strong>Q:</strong> 请回答下述三个问题： </p><p>•tlb_invalidate和tlb_out的调用关系？ </p><p><strong>A:</strong> tlb_invalidate调用tlb_out，tlb_out是叶子函数</p><p>•请用一句话概括tlb_invalidate的作用。 </p><p><strong>A:</strong> 删除某个虚拟地址在 TLB 中的旧表项。</p><p>•逐行解释tlb_out中的汇编代码。</p><p><strong>A:</strong></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LEAF(tlb_out).set noreordermfc0    t0, CP0_ENTRYHI#存储原有的EnryHi寄存器的值到$t0,用于函数结束时恢复mtc0    a0, CP0_ENTRYHI#将传入的参数设置为EnryHi新的值noptlbp#根据EntryHi中的Key(包含VPN与ASID)，查找 TLB 中与之对应的表项，并将表项的索引存入Index寄存器nopmfc0    t1, CP0_INDEX#将tlbp的执行后Index寄存器的结果保存到$t1.set reorderbltz    t1, NO_SUCH_ENTRY#Index寄存器中值小于0,表示没有查到该表项.set noreordermtc0    zero, CP0_ENTRYHImtc0    zero, CP0_ENTRYLO0mtc0    zero, CP0_ENTRYLO1#将三个寄存器中的值置零方便清空noptlbwi#以Index寄存器中的值为索引，将此时EntryHi与EntryLo0、EntryLo1的值写到索引指定的TLB表项中.set reorderNO_SUCH_ENTRY:mtc0    t0, CP0_ENTRYHI#恢复调用前EnryHi寄存器的值j       ra#跳回END(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p><strong>Q:</strong> 从下述三个问题中任选其一回答： </p><p>• 简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS在内存管理上的区别。 </p><p>• 简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上的区别。 </p><p>• 简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</p><blockquote><p>RISC-V 与 MIPS 在内存管理上的区别</p></blockquote><p>RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</p><blockquote><p> RISC-V 内存管理机制</p></blockquote><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>内存布局定义在/kernel/include/mm/memlayout.h当中</p><p>具体内存表如下</p><h5 id="S-Mode内核地址空间布局"><a href="#S-Mode内核地址空间布局" class="headerlink" title="S-Mode内核地址空间布局"></a>S-Mode内核地址空间布局</h5><pre class="line-numbers language-none"><code class="language-none">VA_MAX ----------------&gt;+---------------------------+-------0x7f ffff ffff                        |       TRAMPOLINE          |       BY2PGTRAMPOLINE ------------&gt;+---------------------------+-----------------                        |                           |PHYSICAL_MEMORY_END ---&gt;+---------------------------+-------0x8800 0000                        |                           |kernelEnd -------------&gt;+---------------------------+-----------------                        |       Kernel Data         |textEnd ---------------&gt;+---------------------------+-----------------                        |       Kernel Text         |BASE_ADDRESS, ---------&gt;+---------------------------+-------0x8020 0000kernelStart -/          |                           |                        |       OpenSBI             |PHYSICAL_MEMORY_BASE --&gt;+---------------------------+-------0x8000 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       VIRTIO              |VIRTIO ----------------&gt;+---------------------------+-------0x1000 1000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       UART0               |UART0 -----------------&gt;+---------------------------+-------0x1000 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       PILC                |PILC  -----------------&gt;+---------------------------+-------0x0c00 0000                        |                           |-----------------------&gt;+---------------------------+-----------------                        |       CLINT               |CLINT -----------------&gt;+---------------------------+-------0x0200 0000                        |       invalid memory      |0 ---------------------&gt;+---------------------------+-------0x0000 0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="U-Mode用户地址空间布局"><a href="#U-Mode用户地址空间布局" class="headerlink" title="U-Mode用户地址空间布局"></a>U-Mode用户地址空间布局</h5><img src="/2024/08/22/2024-os-lab2/lab2-Umode.png" style="zoom:50%;"><h4 id="虚拟页式管理（Sv39内存布局）"><a href="#虚拟页式管理（Sv39内存布局）" class="headerlink" title="虚拟页式管理（Sv39内存布局）"></a>虚拟页式管理（Sv39内存布局）</h4><h5 id="39位有效VA"><a href="#39位有效VA" class="headerlink" title="39位有效VA"></a>39位有效VA</h5><p>根据SV-39的约定，对于一个64位的虚拟地址，只使用其低39位来进行地址转换，而高25位不做使用，未来Risc-V有可能用来定义更多的翻译级别。</p><aside> 💡 因此该布局下最大的虚拟地址即为(1&lt;&lt;39)-1，也就是0x7f ffff <h5 id="三级页表机制"><a href="#三级页表机制" class="headerlink" title="三级页表机制"></a>三级页表机制<p>Sv39为页式的内存管理，每一页的大小为4kb，即4096bytes。采用三级页表来完成虚拟地址到物理地址的映射。</p></h5><h5 id="satp寄存器"><a href="#satp寄存器" class="headerlink" title="satp寄存器"></a>satp寄存器</h5><p>satp(Supervisor Address Translation and Protection)寄存器是Risc-V架构下的一个特权寄存器，用来告知cpu根页表的地址，其具体布局如下</p><table><thead><tr><th>63-60</th><th>59-44</th><th>43-0</th></tr></thead><tbody><tr><td>mode</td><td>asid</td><td>ppn</td></tr></tbody></table><ul><li>mode用来表示内存布局，这里我们设置为8，告知cpu我们采取Sv-39内存布局方式</li><li>asid为地址空间的id（暂时先不管）</li><li>ppn为页表基地址的物理页号，由于一页大小为4kb，因此即为页表的物理地址右移12位即可</li></ul><h5 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h5><p>Sv-39的虚拟地址和物理地址格式如下</p><img src="/2024/08/22/2024-os-lab2/lab2-risc-v-va-pa.png"><p>对于一个虚拟地址而言，VPN[2]为第一级页号，查询过程如下：</p><ul><li>satp寄存器存储了根页表的物理地址，将根页表的物理地址加上页表项大小（8bytes）*第一级页号即可找到其对应表项。</li><li>表项的布局如上图（Sv39 page table entry），其53-10位为下一级页表（第二级页表）的页号，低10位用作标记位</li><li>由此获得了第二级页表的基地址（页号左移12位），此时再用VPN[1]去查询第三级页表的基地址即可。</li><li>如此获得第三级页表项，其存储的页号即为最终对应的物理页号，将其左移12位再加上page offset，就得到了对应的物理地址</li></ul><img src="/2024/08/22/2024-os-lab2/lab2-va2pa.png"><h6 id="页表项的标记位"><a href="#页表项的标记位" class="headerlink" title="页表项的标记位"></a>页表项的标记位</h6><img src="/2024/08/22/2024-os-lab2/lab2-%E9%A1%B5%E8%A1%A8%E9%A1%B9%E6%A0%87%E8%AE%B0%E4%BD%8D.png"><p>上述过程已经可以查询到对应的物理地址，但页表项中的标记位也携带了一些额外的信息，下面加以解释</p><ul><li>RSW: Reserved for use by Supervisor softWare</li><li>D: Dirty bit<ul><li>exception: a virtual page is written and the D bit is clear</li></ul></li><li>A: Accessed bit<ul><li>exception: a virtual page is accessed and the A bit is clear</li></ul></li><li>可以将DA 总是设置为 1避免产生上述异常（存疑，qs文档）</li><li>U: User mode bit<ul><li>U-mode 访问许可位</li><li>S-mode <em>一般</em> 不可访问</li></ul></li><li>For non-leaf PTEs, the D, A, and U bits are reserved for future standard use</li><li>R: Read bit</li><li>W: Write bit</li><li>X: eXecute bit</li><li>RWX 具体作用见下</li><li>V: Valid bit<ul><li>有效位</li></ul></li></ul><p>在 RISC-V 中，PTE 有两种：</p><ul><li>叶 PTE：指向一个物理页 PPN</li><li>非叶 PTE：指向一个页表 PPN</li></ul><p>实际上位于任何级的 PTE 都可能成为叶 PTE，也就是不通过三级页表映射就查询到一个物理地址（RX非0）。非最低级的 PTE 作为叶 PTE 时则会形成超级页。</p><p>例如，如果第一级页表所查询到的页表项的R位或X位非0，则页表项中的PPN[2]即为物理地址的页号，而此时其一页的大小也对应的为$2^{12+9+9}=2^{30}$bits（此时PPN[1]和PPN[0]都为0，否则抛出异常），也就是1GB，这就是一个超级页。因此Sv-39下页的大小可能为4Kb，2Mb和1Gb。</p><img src="/2024/08/22/2024-os-lab2/lab2-RXW.png"><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h3><p>在  include/pmap.h 、 include/mmu.h 中： </p><ul><li>PDX(va) ：页目录偏移量（查找遍历页表时常用） </li><li>PTX(va) ：页表偏移量（查找遍历页表时常用） </li><li>PTE_ADDR(pte) ：获取页表项中的物理地址（读取 pte 时常用） </li><li>PADDR(kva) ：kseg0 处虚地址  →  物理地址 </li><li>KADDR(pa) ：物理地址  →  kseg0 处虚地址（读取 pte 后可进行转换） </li><li>va2pa(Pde *pgdir, u_long va) ：查页表，虚地址  →  物理地址（测试时常用）</li><li>pa2page(u_long pa) ：物理地址  →  页控制块（读取 pte 后可进行转换） </li><li>page2pa(struct Page *pp) ：页控制块  →  物理地址（填充 pte 时常用）</li></ul><h3 id="1-MIPS4Kc内存映射布局"><a href="#1-MIPS4Kc内存映射布局" class="headerlink" title="1.MIPS4Kc内存映射布局"></a>1.MIPS4Kc内存映射布局</h3><table><thead><tr><th></th><th>虚拟地址</th><th>物理地址</th><th>访问方式</th><th>用途</th></tr></thead><tbody><tr><td>kseg2</td><td>0xc00000000xffffffff</td><td>通过 TLB 转换成物理地址</td><td>通过cache 访存</td><td></td></tr><tr><td>kseg1</td><td>0xa0000000~0xbfffffff</td><td>虚拟地址的最高 3 位置 0</td><td>不通过cache 访存</td><td>可以用于访问外设</td></tr><tr><td>kseg0</td><td>0x80000000~0x9fffffff</td><td>虚拟地址的最高位置0</td><td>通过cache 访存</td><td>用于存放内核代码与数据</td></tr><tr><td>kuseg</td><td>0x00000000~0x7fffffff</td><td>通过 TLB 转换成物理地址</td><td>通过cache 访存</td><td>用于存放用户程序代码与数据</td></tr></tbody></table><h3 id="2-物理内存的管理方法（链表法）"><a href="#2-物理内存的管理方法（链表法）" class="headerlink" title="2.物理内存的管理方法（链表法）"></a>2.物理内存的管理方法（链表法）</h3><p>为了使用链表，我们需要定义两个结构 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code>。前者表示链表头或链表本身的类型，后者表示链表中元素的类型。通过宏定义可知，<code>LIST_HEAD(name, type)</code> 表示创建一个元素类型为 <code>type</code> 的链表，这个链表类型名为 <code>name</code>。<code>LIST_ENTRY(type)</code> 表示创建一个类型为 <code>type</code> 的链表元素。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>  </span><span class="token comment">/* next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-虚拟内存的管理方法（两级页表）"><a href="#3-虚拟内存的管理方法（两级页表）" class="headerlink" title="3.虚拟内存的管理方法（两级页表）"></a>3.虚拟内存的管理方法（两级页表）</h3><p>指导书如是说：</p><blockquote><p>MOS中用PADDR 与KADDR 这两个宏可以对位于kseg0 的虚拟地址和对应的物理地址进行转换。 但是，对于位于kuseg 的虚拟地址，MOS中采用两级页表结构对其进行地址转换。</p></blockquote><p>提及函数及作用：</p><h4 id="int-pgdir-walk-Pde-pgdir-u-long-va-int-creat-Pte-ppte"><a href="#int-pgdir-walk-Pde-pgdir-u-long-va-int-creat-Pte-ppte" class="headerlink" title="int pgdir_walk(Pde *pgdir, u_long va, int creat, Pte **ppte)"></a>int pgdir_walk(Pde *pgdir, u_long va, int creat, Pte **ppte)</h4><p>将一级页表基地址pgdir对应的两级页表结构中va虚拟地址所在的二级页表项的指针 存储在 ppte指向的空间上。</p><blockquote><p>/* 将 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上<br>       *ppte = va 虚拟地址所在的二级页表项的指针<br>             = 二级页表基地址（指向二级页表的指针） + va所对的二级页表项在二级页表的偏移</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span>ppte <span class="token operator">=</span> <span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>二级页表基地址（指向二级页表的指针）：        页目录项     <span class="token operator">-&gt;</span>   二级页表的物理地址     <span class="token operator">-&gt;</span>     二级页表的虚拟地址           <span class="token operator">-&gt;</span>         指向二级页表的指针<span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span> 到 <span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span> 到 <span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span> 到 <span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pgdir_entryp<span class="token punctuation">)</span><span class="token punctuation">)</span>va所对的二级页表项在二级页表的偏移： <span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p> * Post-Condition:</p><p> *  If we’re out of memory, return -E_NO_MEM.</p><p> *  Otherwise, we get the page table entry, store</p><p> *  the value of page table entry to *ppte, and return 0, indicating success.</p></blockquote><h4 id="int-page-insert-Pde-pgdir-u-int-asid-structPage-pp-u-long-va-u-int-perm"><a href="#int-page-insert-Pde-pgdir-u-int-asid-structPage-pp-u-long-va-u-int-perm" class="headerlink" title="int page_insert(Pde *pgdir,u_int asid,structPage *pp,u_long va,u_int perm)"></a>int page_insert(Pde *pgdir,u_int asid,structPage *pp,u_long va,u_int perm)</h4><p>将一级页表基地址pgdir对应的两级页表结构中虚拟地址va映射到页控制块pp对应的物理页面，并将页表项权限为设置为perm。</p><blockquote><p> * Post-Condition:</p><p> *  Return 0 on success</p><p> *  Return -E_NO_MEM, if page table couldn’t be allocated</p></blockquote><blockquote><p>If there is already a page mapped at <code>va</code>, call page_remove() to release this mapping.</p></blockquote><h4 id="struct-Page-page-lookup-Pde-pgdir-u-long-va-Pte-ppt"><a href="#struct-Page-page-lookup-Pde-pgdir-u-long-va-Pte-ppt" class="headerlink" title="struct Page *page_lookup(Pde *pgdir,u_long va,Pte **ppt)"></a>struct Page *page_lookup(Pde *pgdir,u_long va,Pte **ppt)</h4><p>返回一级页表基地址pgdir对应的两级页表结构中虚拟地址va映射的物理页面的页控制块，同时将ppte指向的空间设为对应的二级页表项地址。</p><p>就是里面有一个pgdir_walk，多一步把va经过页表查询得到的pa转化成Page结构体然后返回。</p><h4 id="void-page-remove-Pde-pgdir-u-intasid-u-longva"><a href="#void-page-remove-Pde-pgdir-u-intasid-u-longva" class="headerlink" title="void page_remove(Pde*pgdir,u_intasid,u_longva)"></a>void page_remove(Pde*pgdir,u_intasid,u_longva)</h4><p>删除一级页表基地址 pgdir对应的两级页表结构中虚拟地址va对物理地址的映射。如果存在这样的映射，那么对应 物理页面的引用次数会减少一次。</p><p>注：一级页表项的指针（Pde*）和二级页表项的指针（Pte*）的值都是虚拟地址，对他们取值后是为其分配的物理地址。</p><h3 id="4-TLB清除与重填的流程"><a href="#4-TLB清除与重填的流程" class="headerlink" title="4.TLB清除与重填的流程"></a>4.TLB清除与重填的流程</h3><p>tlbr：以 Index 寄存器中的值为索引，读出TLB中对应的表项到EntryHi与EntryLo0、EntryLo1。</p><p>tlbwi：以 Index 寄存器中的值为索引，将此时EntryHi与EntryLo0、EntryLo1 的值写到索引指定的TLB表项中。</p><p>tlbwr：将 EntryHi 与 EntryLo0、EntryLo1 的数据随机写到一个 TLB 表项中（此处使用Random 寄存器来“随机”指定表项，Random寄存器本质上是一个不停运行的循环计数器）</p><p>tlbp：根据EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将表项的索引存入Index 寄存器（若未找到匹配项，则Index最高位被置1）</p><h3 id="5-叶子函数和非叶子函数"><a href="#5-叶子函数和非叶子函数" class="headerlink" title="5.叶子函数和非叶子函数"></a>5.叶子函数和非叶子函数</h3><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><h3 id="lab2-exam"><a href="#lab2-exam" class="headerlink" title="lab2-exam"></a>lab2-exam</h3><p><strong>题目概要：</strong>统计所有二级页表项中，其对应的物理页框的引用数目大于某个值的二级页表项数目。</p><p><strong>主要思路：</strong></p><p>利用zy学姐博客中的对所有二级页表项的遍历方法，只需完善if判断条件：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//统计满足条件的页表项的数量</span>Pde <span class="token operator">*</span>pde<span class="token punctuation">;</span>Pte <span class="token operator">*</span>pte<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>pde <span class="token operator">=</span> pgdir <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pde <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//当前页目录是否有效</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span>Pte<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pde<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">////当前页表是否有效</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*if判断条件*/</span>           count<span class="token operator">++</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lab2-extra"><a href="#lab2-extra" class="headerlink" title="lab2-extra"></a>lab2-extra</h3><p><strong>题目概要：</strong>简易版伙伴系统(第一眼还以为是21年那个很难很难的考题)</p><p>伙伴系统将高地址划32MB分为数个内存区间，每个内存区间有两种状态：已分配和未分配。每个内存区间的大小只可能是 4KB和8KB。初始，32MB均被化为8KB的内存区间且状态均为未分配。buddy_free_list[0]链表中为存储大小为4KB的空闲空间，buddy_free_list[1]链表中存储大小为8KB的空闲空间。要求实现分配函数 <code>buddy_alloc</code> 和释放函数 <code>buddy_free</code></p><p><strong>主要思路：</strong></p><p>分配函数 <code>buddy_alloc</code> ：由于只有两种分配空间大小的选择，所以逻辑很简单。</p><p>释放函数 <code>buddy_free</code>：释放8KB的空间时直接释放，释放4KB的空间时需要遍历buddy_free_list[0]寻找伙伴是否空闲：空闲需要合并后插入buddy_free_list[1]，否则直接插入buddy_free_list[0]。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://yanna-zy.gitee.io/2023/04/10/BUAA-OS-2/#post-comment">https://yanna-zy.gitee.io/2023/04/10/BUAA-OS-2/#post-comment</a></li><li><a href="https://zhuanlan.zhihu.com/p/626899526">RISC-V Sv39 虚拟内存总结 - 知乎 (zhihu.com)</a></li></ol><!--39)-1，也就是0x7f--></aside>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab0</title>
      <link href="/2024/08/21/2024-os-lab0/"/>
      <url>/2024/08/21/2024-os-lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>使用add命令之前，README.txt处于<code>Untracked</code>(未跟踪的文件)；使用add命令之后，README.txt处于<code>Staged</code>(要提交的变更)；提交README.txt之后，其处于<code>Unmodified</code>；修改README.txt之后，其处于<code>Modified</code>(尚未暂存以备提交的变更)。故Modified.txt和Untracked.txt中status并不相同。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.2.png"><p>add the file: <code>git add</code></p><p>stage the file: <code>git add</code></p><p>commit: <code>git commit</code></p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><ol><li><p>代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p><p><code>git restore print.c</code> 或者 <code>git checkout -- print.c</code> (将工作区恢复为暂存区的样子)</p></li><li><p>代码文件 print.c 被错误删除后，执行了 <code>git rm print.c</code> 命令，此时应当使用什么命令将其恢复？</p><p><code>git rm print.c</code> 已将文件从暂存区删除，故先通过 <code>git reset HEAD print.c</code> 将暂存区恢复master分支的样子， 再使用 g<code>it restore print.c</code> 或者 <code>git checkout -- print.c</code></p></li><li><p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p><p><code>git rm hello.txt</code> 直接从暂存区删除文件，工作区不会做出改变</p></li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>提交三个版本之后：</p><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-1.png" style="zoom:50%;"><p>回退版本二：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-2.png" style="zoom:50%;"></p><p>通过hashcode回到版本三：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.4-3.png" style="zoom:50%;"></p><p><strong>!!值得注意的是：git reset –hard会将工作区、暂存区和当前分支都重置到指定的提交状态，因此会更改工作区的内容。如果有未提交的更改，这些更改会被丢弃。</strong></p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> first<span class="token builtin class-name">echo</span> second <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> third <span class="token operator">&gt;</span> output.txt<span class="token builtin class-name">echo</span> forth <span class="token operator">&gt;&gt;</span> output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;</code> :重定向命令的标准输出到文件(覆盖原文件)</p><p><code>&gt;&gt;</code> :命令的输出追加到指定文件</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>command文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-1.png" style="zoom:50%;"></p><p>result文件内容：<br><img src="/2024/08/21/2024-os-lab0/img/Thinking%200.6-2.png" style="zoom:80%;"></p><p>解释说明:（可以从test文件的内容入手）<br>test给a赋值为1，给b赋值为2，给c赋值为a+b，即c的值为3；之后将c、b、a的值依次重定向输入到file1、file2、file3；接着把file1、file2、file3追加到file4；最后将file4的结果输出到result中。</p><ul><li><p>echo echo Shell Start 与 echo ‘echo Shell Start’ 效果是否有区别：没有区别</p></li><li><p>echo echo $c&gt;file1 与 echo ‘echo $c&gt;file1’ 效果是否有区别 ：有区别，前者将echo $c输出到file1中($c会替换为变量的值)，后者将字符串echo $c&gt;file1输出到标准输出($c不会被替换)。</p><p>除此之外，“ ”中的$1会被解释，而’ ‘中的$1不会被解释。</p></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h3><p>$&lt;:代表第一个依赖文件</p><p>$^:代表所有的依赖文件</p><p>$@:target内容</p><p>*.o:所有的.o文件</p><p>*.c:所有的.c文件</p><p>外层Makefile调用内层Makefile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">all: test.o funcdir<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> funcdir//进入内层文件夹gcc funcdir/function.o test.o <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>.PHONY: cleanclean:<span class="token function">rm</span> <span class="token parameter variable">-f</span> *.o <span class="token builtin class-name">test</span><span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean <span class="token parameter variable">-C</span> funcdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shell中的表达式计算"><a href="#shell中的表达式计算" class="headerlink" title="shell中的表达式计算"></a>shell中的表达式计算</h3><ul><li><p>expr 算术表达式</p><ol><li><p>运算符之间要有空格，例如：expr&lt;空格&gt;变量&lt;空格&gt;运算符&lt;空格&gt;变量。  <code>expr 2 + 3</code>, <code>c=$(expr $a + $b)</code></p></li><li><p>乘法运算符使用 *，乘法运算符前需要加 \。例如：<code>expr 2 \* 3</code></p></li></ol></li><li><p>$[算术表达式] 及 $((算术表达式)) (无格式限制)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span><span class="token number">5</span>+9<span class="token punctuation">]</span><span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">+</span><span class="token number">9</span><span class="token variable">))</span></span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$a<span class="token operator">/</span>$b<span class="token variable">))</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="shell单引号、双引号和反引号"><a href="#shell单引号、双引号和反引号" class="headerlink" title="shell单引号、双引号和反引号"></a>shell单引号、双引号和反引号</h3><p>单引号和双引号用于变量值出现空格时，比如 name=zhang san 这样执行就会出现问  题，而必须用引号括起来，比如 name=”zhang san”。</p><ul><li><p>单引号括起来的字符都是普通字符，就算特殊字符也不再有特殊含义</p></li><li><p>双引号括起来的字符中，”$“、”\“和反引号是拥有特殊含义的，”$“代表引用变量的值(如果需要在双引号中间输出”$”和反引号，则要在符号前加入转义符”\“)</p></li><li><p>反引号代表引用命令</p><p>如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和 $(命令) 是一样的</p><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">$ echo lsls$ echo `ls`code err.txt handle-ps.sh hello.c ps.out test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="sed-grep-awk"><a href="#sed-grep-awk" class="headerlink" title="sed grep awk"></a>sed grep awk</h3><ul><li><p>sed</p><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">test</span><span class="token operator">=</span>hello $ <span class="token builtin class-name">echo</span> hello WORLD <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/<span class="token variable">$test</span>/HELLO"</span> HELLO WORLD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token number">1</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token keyword">then</span>        <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span>        <span class="token assign-left variable">m</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-eq</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>         <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token variable">$1</span><span class="token keyword">fi</span><span class="token assign-left variable">f</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$n</span>+<span class="token variable">$m</span><span class="token punctuation">]</span><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">${f}</span>p"</span> err.txt <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>​lab0的考核主要针对基础工具vim、Makefile编写、shell编写及命令行使用，难度并不在于知识本身的难度，而是对知识的掌握熟知程度。指导书并没有详细给出常用指令的所有用法，需要课下作业中查阅学习更完全更准确的用法。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li><p>Ctrl+C 终止当前程序的执行</p></li><li><p>Ctrl+Z 挂起当前程序 (fg [job_spec]，job_spec:挂起编号，默认最近挂起进程)</p></li><li><p>Ctrl+D 终止输入(若正在使用shell，则退出当前 shell)</p></li><li><p>Ctrl+L 清屏</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://c.biancheng.net/view/951.html">https://c.biancheng.net/view/951.html</a></p><p><a href="https://www.cnblogs.com/zakun/p/linux-cmd-sed.html">Linux之sed命令详解 - zakun - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_OS_lab1</title>
      <link href="/2024/08/21/2024-os-lab1/"/>
      <url>/2024/08/21/2024-os-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p><strong>Q:</strong> 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、 ld、 readelf、 objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。  </p><p><strong>A:</strong></p><blockquote><p>上方为只经过编译的文件的反汇编结果</p><p>下方为经过编译和链接之后的文件的反汇编结果</p></blockquote><ul><li><p>x86工具链(重复附录中的操作)</p><img src="/2024/08/21/2024-os-lab1/lab1-x86.png" style="zoom:10%;"></li><li><p>MIPS交叉编译工具链</p></li></ul><img src="/2024/08/21/2024-os-lab1/lab1-mips.png" style="zoom:30%;"><pre class="line-numbers language-(shell)" data-language="(shell)"><code class="language-(shell)">~/test_lab1 $ mips-linux-gnu-gcc -E hello.c &gt; mips_1~/test_lab1 $ mips-linux-gnu-gcc -c hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS hello.o &gt; mips_2 ~/test_lab1 $ mips-linux-gnu-gcc -o misp.out hello.c~/test_lab1 $ mips-linux-gnu-objdump -DS mips.out &gt; mips_3  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>objdump参数含义：</p><p>-d, –disassemble        Display assembler contents of executable sections</p><p>​反汇编那些特定指令机器码的section<br>-D, –disassemble-all    Display assembler contents of all sections</p><p>​反汇编所有的section<br>​    –disassemble=<sym>  Display assembler contents from <sym><br> -S, –source             Intermix source code with disassembly<br>​    –source-comment[=<txt>] Prefix lines of source code with <txt><br> -s, –full-contents      Display the full contents of all sections requested</txt></txt></sym></sym></p></li></ul><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><p><strong>Q:</strong> 思考下述问题：</p><p>• 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。</p><p><strong>A:</strong></p><img src="/2024/08/21/2024-os-lab1/lab1-1.png" style="zoom:33%;"><img src="/2024/08/21/2024-os-lab1/lab1-2.png" style="zoom:30%;">• 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）<p><strong>A:</strong></p><p>readelf头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-readelf.png" style="zoom:33%;"><p>hello头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-hello.png" style="zoom:33%;"><p>系统工具readelf头部文件信息：</p><img src="/2024/08/21/2024-os-lab1/lab1-readelfpub.png" style="zoom:33%;"><p>tools/readelf/Makefile中的readelf与hello:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">readelf: main.o readelf.o<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>readelf: main.o readelf.o        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span>hello: hello.c        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span> <span class="token parameter variable">-m32</span> <span class="token parameter variable">-static</span> <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello在编译链接时添加了-m32 -static -g选项，使得生成的目标文件是32位、静态链接并且包含调试信息的。32位指的是指令集架构和内存地址的位数。我们可以看到hello的头部文件信息中类别为<strong>ELF32</strong>，而默认情况下，在64位操作系统上使用 GCC 编译器生成的可执行文件通常是64位的，故我们课程组提供的 readelf 头部文件信息中类别为<strong>ELF64</strong>。</p><blockquote><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p></blockquote><p>但是在课程组提供的 readelf.c 文件中，表示 ELF 头部信息的结构体大小为32位，故课程组的 readelf 可以用来解析 hello 而不可以用来解析它自身。</p><p>如果课程组的readelf的编译方式和hello一样，即如下述形式，则readelf_temp可以解析自身。</p><img src="/2024/08/21/2024-os-lab1/lab1-readelf_temp.png" style="zoom:33%;"><p>而之所以系统工具 readelf 都能够解析，是因为 readelf 是一个通用的 ELF 文件解析工具，可以处理不同版本的 ELF 文件。当用户使用readelf命令解析一个 ELF 文件时，readelf 会根据文件的格式自动识别是 ELF32 还是 ELF64，并相应地解析文件的结构和内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//readelf.c</span><span class="token keyword">int</span> <span class="token function">is_elf_format</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf32_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span>binary<span class="token punctuation">;</span>    <span class="token keyword">return</span> size <span class="token operator">&gt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf32_Ehdr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG0 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG1 <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG2 <span class="token operator">&amp;&amp;</span>        ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p><strong>Q:</strong> 在理论课上我们了解到， MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</p><p><strong>A:</strong> QEMU 模拟器支持直接加载 ELF 格式的内核，也就是说， QEMU 已经提供了 bootloader 的引导（启动）功能。 MOS 操作系统不需要再实现 bootloader的功能。在 MOS 操作系统的运行第一行代码前，我们就已经拥有一个正常的程序运行环境，内存和一些外围设备都可以正常使用。QEMU 支持加载 ELF 格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口，启动就完成了。</p><ol><li>Makefile 中使用的$(link_script) 来生成的内核</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">link_script             :<span class="token operator">=</span> kernel.lds<span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>modules<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>LD<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token parameter variable">-o</span> <span class="token variable"><span class="token variable">$(</span>mos_elf<span class="token variable">)</span></span> <span class="token parameter variable">-N</span> <span class="token parameter variable">-T</span> <span class="token variable"><span class="token variable">$(</span>link_script<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>objects<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>kernel.lds文件中有<code>ENTRY(_start)</code>这 一行命令，这就是内核的入口</li><li><code>start.S</code>中sp寄存器设置到内核栈空间的位置上，随后跳转到mips_init函数(C语言的主函数)</li></ol><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="1-0-常用操作"><a href="#1-0-常用操作" class="headerlink" title="1.0 常用操作"></a>1.0 常用操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DS</span> 要反汇编的目标文件名 <span class="token operator">&gt;</span> 导出文本文件名 <span class="token function">file</span> 要查看类型的目标文件名 <span class="token comment">#获得文件类型</span><span class="token function">grep</span> <span class="token parameter variable">-R</span> printcharc <span class="token comment">#-R的意思是在多个子目录中找</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-1-ELF相关"><a href="#1-1-ELF相关" class="headerlink" title="1.1 ELF相关"></a>1.1 ELF相关</h3><ul><li><strong>MemSiz与FileSiz(ELF头文件中段相关信息)</strong></li></ul><blockquote><p>Offset:该段（segment）的数据相对于 ELF文件的偏移。</p><p>VirtAddr:该段最终需要被加载到内存的哪个位置。</p><p>FileSiz:该段的数据在文件中的长度。</p><p>MemSiz:该段的数据在内存中所应当占的大小。</p></blockquote><p>MemSiz永远大于等于FileSiz。若MemSiz大于FileSiz，则操作系统在加载程序的时候，会首先将文件中记录的数据加载到对应的VirtAddr处。之后，向内存中填0 ，直到该段在内存中的大小达到MemSiz为止。那么为什么MemSiz有时候会大于FileSiz 呢？这里举这样一个例子：C语言中未初始化的全局变量，我们需要为其分配内存，但它又不需要被初始化成特定数据。因此，在可执行文件中也只记录它需要占用内存(MemSiz)，但在文件中却没有相应的数据（因为它并不需要初始化成特定数据）。故而在这种情况下， MemSiz会大于FileSiz。这也解释了，为什么C语言中全局变量会有默认值0。这是因为操作系统在加载时将所有未初始化的全局变量所占的内存统一填了0。</p><ul><li><strong>ELF头部标识符</strong></li></ul><p>当一个 ELF 文件的类型被标识为 ELF32 时，表示该文件采用了32位的标识符、地址和偏移等字段来描述文件的各个部分，如节表、程序头部、符号表等。 ELF64 同理。</p><h3 id="1-2-printk实现相关"><a href="#1-2-printk实现相关" class="headerlink" title="1.2 printk实现相关"></a>1.2 printk实现相关</h3><ul><li><strong>可变参数列表</strong></li></ul><p>当函数参数列表末尾有省略号时，该函数即有变长的参数表。</p><p>由于需要定位变长参数表的起始位置，函数需要含有至少一个固定参数，且变长参数必须在参数表的末尾。 </p><p>stdarg.h 头文件中为处理变长参数表定义了一组宏和变量类型如下： </p><p>va_list，变长参数表的变量类型； </p><p>va_start(va_list ap, lastarg)，用于初始化变长参数表的宏； </p><p>va_arg(va_list ap, 类型)，用于取变长参数表下一个参数的宏； </p><p>va_end(va_list ap)，结束使用变长参数表的宏。</p><ul><li><strong>回调函数</strong></li></ul><p>回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义主函数，回调函数作为参数</span>function <span class="token function">A</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token char">'我是主函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//定义回调函数</span>function <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"console.log('我是回调函数')"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//模仿耗时操作  </span><span class="token punctuation">}</span><span class="token comment">//调用主函数，将函数B传进去</span><span class="token function">A</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出结果</span>我是主函数我是回调函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-tmux操作"><a href="#1-3-tmux操作" class="headerlink" title="1.3 tmux操作"></a>1.3 tmux操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux<span class="token comment">#启动</span>tmux <span class="token builtin class-name">set</span> mouse on <span class="token comment">#嘿嘿启用鼠标</span><span class="token builtin class-name">exit</span><span class="token comment">#退出/ctrl+D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>会话</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#新建会话</span>$ tmux detach<span class="token comment">#分离会话/ctrl+b d</span>$ tmux <span class="token function">ls</span><span class="token comment"># or</span>$ tmux list-session<span class="token comment">#查看所有会话</span><span class="token comment"># 使用会话编号</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux attach <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#接入会话</span><span class="token comment"># 使用会话编号</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux kill-session <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#杀死会话</span><span class="token comment"># 使用会话编号</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token number">0</span><span class="token comment"># 使用会话名称</span>$ tmux switch <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>session-name<span class="token operator">&gt;</span><span class="token comment">#切换会话</span>$ tmux rename-session <span class="token parameter variable">-t</span> <span class="token number">0</span> <span class="token operator">&lt;</span>new-name<span class="token operator">&gt;</span><span class="token comment">#重命名会话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗口</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tmux new-window<span class="token comment"># 新建一个指定名称的窗口</span>$ tmux new-window <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#新建窗口</span><span class="token comment"># 切换到指定编号的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-number<span class="token operator">&gt;</span><span class="token comment"># 切换到指定名称的窗口</span>$ tmux select-window <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>window-name<span class="token operator">&gt;</span><span class="token comment">#切换窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>窗格</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 划分上下两个窗格</span>$ tmux split-window<span class="token comment"># 划分左右两个窗格</span>$ tmux split-window <span class="token parameter variable">-h</span><span class="token comment">#划分窗格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab1上机题目本身难度不大</p><ul><li>lab1-exam:更改输出格式<br>考察点在于读入具有变长参数列表的函数参数</li><li>lab1-extra:实现简化的scanf(%d %x %s %c)<br>考察点在于编写具有变长参数列表的函数，练习使用回调函数。<br>编写逻辑并不复杂，识别百分号后的输入控制符规定的格式→根据格式获取指针→由回调函数in从控制台读取参数→存入指针指向的内存区域。<br>但是很可惜，没有通过lab1-extra。原因也很可惜，主要有两个问题，第二个十分严重的问题没有来得及在课上解决。。。<br>第一个问题:判断是否有负号之后，没有再读入下一个字符。<br>第二个问题:在明晃晃的注释下我又从控制台读取了下一个字符。</li></ul><img src="/2024/08/21/2024-os-lab1/lab1-%E5%AE%9E%E9%AA%8C.png" style="zoom:33%;"><p>309行注释掉的部分是实验课上错误的实现方式，每一种case都犯了类似的错误。</p><p>希望下次会做得好一些吧</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oopre课程总结反思</title>
      <link href="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/"/>
      <url>/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/</url>
      
        <content type="html"><![CDATA[<h3 id="oopre课程总结反思"><a href="#oopre课程总结反思" class="headerlink" title="oopre课程总结反思"></a>oopre课程总结反思</h3><h4 id="最终架构设计"><a href="#最终架构设计" class="headerlink" title="最终架构设计"></a>最终架构设计</h4><h6 id="价值体"><a href="#价值体" class="headerlink" title="价值体"></a>价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/1.jpeg" class=""><p>这一部分类所实例化的对象是完成需求需要处理的重头戏。</p><p><code>Bottle</code>类、<code>Food</code>类、<code>Equipment</code>类的属性均只是设有其基本属性及方法。<code>Adventurer</code>类除基础属性之外，为满足需求，还包括了与前三者相关的属性（一个名为xx的HashMap表示所拥有的及一个名为xxBackpack的HashMap表示所携带的  xx为bottle、food、equipment），以及名为laborers的HashMap表示所雇佣的冒险者。</p><p><strong>待改进之处</strong>：学习优秀代码之后发现，确实把与Backpack相关的属性方法从<code>Adventurer</code>类中抽离出来会更好一些。一方面<code>Adventurer</code>类中方法会大幅减少，功能形式会更接近其他价值体，另一方面代码总体架构也会更为清晰明了。</p><h6 id="非价值体"><a href="#非价值体" class="headerlink" title="非价值体"></a>非价值体</h6><img src="/2024/08/21/oopre-ke-cheng-zong-jie-fan-si/2.png" class=""><p>这一部分类所实例化的对象更多的是为了辅助价值体实现需求。</p><p><code>FightLog</code>类记录每条战斗日志，<code>FightMode</code>类执行战斗日志，<code>Input</code>类中logGeneral与modeGeneral用来分别储存所有的前两者的记录。<code>Shop</code>类完成所有的冒险者与商店之间的交互。</p><p><strong>待改进之处</strong>：编写之时只是为了方便将logGeneral、modeGeneral、teamById、teamByName放在<code>Main</code>函数并传入<code>Input</code>类中作为其属性，但并没有实际的含义。在优秀代码中看到了一份应用单例模式构造一个新的<code>World</code>类的代码，我的这些确实作为只能实例化一次的游戏世界的属性会更为合理更有意义一些。</p><h6 id="历次迭代的架构调整"><a href="#历次迭代的架构调整" class="headerlink" title="历次迭代的架构调整"></a>历次迭代的架构调整</h6><p>hw2-&gt;hw3：将<code>Main</code>函数中的对不同指令的处理抽离到一个<code>Input</code>类中</p><p>hw3-&gt;hw4：增加<code>FightLog</code>类和<code>FightMode</code>类，前者用来记录战斗日志，后者用来执行日志</p><p>hw4-&gt;hw6：实现<code>Bottle</code>类和<code>Equipment</code>类的继承，及<code>Community</code>接口</p><p>hw6-&gt;hw7：在<code>Shop</code>类中实现单例模式</p><h4 id="关于Junit"><a href="#关于Junit" class="headerlink" title="关于Junit"></a>关于Junit</h4><p>值得肯定的是，编写的Junit确实帮助我找到了不少的bug，得益于它更加独立分块的单元测试和自行构造的十分简单的数据，往往十分有助于发现问题所在。</p><p>但是，更多的Junit的编写是为了通过评测机的要求，而且一般Junit的编写是一个十分让人破防的事情👉👈。并且我从控制台输入的指令写导Junit里面真的实现很不优雅(敲打)</p><h4 id="oopre学习心得体会"><a href="#oopre学习心得体会" class="headerlink" title="oopre学习心得体会"></a>oopre学习心得体会</h4><p>第一次接触面向对象编程，我最最最直观的体会主要有以下几点：</p><ol><li>它相较于面向过程要求我们有更为清晰的代码结构。从每个类中方法的构造、对实例化对象的管理，到类与类之间的继承、接口的实现，都需要仔细的考量。因而每次完成作业总要呆呆对着电脑想很久…</li><li>它要求我们每一次的迭代要“留有余地”。迭代式的作业，除了每次实现需求之外，需要合理地估计需求易变性，尽可能地让后续的操作优雅，否则很快就会迎来代码重构(×  然而，面对特定的实现目的，代码重构有时是不可避免的。适时的代码框架的修改能够改善程序的设计复杂性， 使得代码更容易理解 。</li><li>它把代码组织成类和对象的形式，每个类都有自己的属性和方法，使得代码更加模块化和可维护，同时所描述的关系和行为也更为贴近实际问题。</li></ol><h4 id="对oopre课程简单建议"><a href="#对oopre课程简单建议" class="headerlink" title="对oopre课程简单建议"></a>对oopre课程简单建议</h4><p>总体课程体验还是相当棒的，但是美中不足的一点是个人感觉还没有完全领会到应用设计模式真正的有益之处(很有可能是因为没有完全理解)，或许下次的oopre课程作业可以在这方面有更多的应用，通过实实在在的代码编写领会设计模式。</p><h4 id="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝"><a href="#再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步-庆祝-庆祝" class="headerlink" title="再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/"></a>再次感谢吴际老师和助教老师们帮助Java小白迈出了面向对象的第一步 \庆祝/\庆祝/</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 2024_OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/13/hello-world/"/>
      <url>/2023/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
